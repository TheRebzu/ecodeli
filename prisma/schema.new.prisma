// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Modèles d'utilisateurs
model User {
  id            String        @id @default(cuid())
  name          String?
  email         String        @unique
  emailVerified DateTime?
  password      String?
  image         String?
  role          UserRole      @default(CLIENT)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  lastLoginAt   DateTime?

  // Relations
  accounts         Account[]
  sessions         Session[]
  clientAnnouncements    Announcement[]  @relation("ClientAnnouncements")
  delivererAnnouncements Announcement[]  @relation("DelivererAnnouncements")
  clientAppointments     Appointment[]   @relation("ClientAppointments")
  providerAppointments   Appointment[]   @relation("ProviderAppointments")
  stores          Store[]
  services        Service[]
  
  // Nouvelles relations pour les profils spécifiques aux rôles
  clientProfile   ClientProfile?
  delivererProfile DelivererProfile?
  serviceProvider ServiceProvider?
  verificationTokens VerificationToken[]
  passwordResetTokens PasswordResetToken[]
  storageRentals  StorageRental[]
  tutorialProgress TutorialProgress?
  notifications Notification[]
  notificationPreference NotificationPreference?
  pushSubscriptions PushSubscription[]

  // Invoice relations
  merchantInvoices Invoice[] @relation("MerchantInvoices")
  providerInvoices Invoice[] @relation("ProviderInvoices")
}

enum UserRole {
  CLIENT
  DELIVERER
  MERCHANT
  PROVIDER
  ADMIN
}

// Modèles d'authentification (compatibles NextAuth)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Tokens pour la vérification d'email et réinitialisation de mot de passe
model VerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  expires   DateTime
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  expires   DateTime
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

// Modèles métier
model Announcement {
  id                String               @id @default(cuid())
  title             String
  description       String               @db.Text
  pickupAddress     String
  deliveryAddress   String
  packageSize       PackageSize
  packageWeight     Float
  packageValue      Float
  deadline          DateTime
  price             Float
  requiresInsurance Boolean              @default(false)
  status            AnnouncementStatus   @default(OPEN)
  paymentStatus     PaymentStatus?
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt

  // Relations
  clientId    String
  client      User                @relation("ClientAnnouncements", fields: [clientId], references: [id])
  delivererId String?
  deliverer   User?               @relation("DelivererAnnouncements", fields: [delivererId], references: [id])
  deliveries  Delivery[]
  payments    Payment[]
}

enum PackageSize {
  SMALL
  MEDIUM
  LARGE
  EXTRA_LARGE
}

enum AnnouncementStatus {
  OPEN
  ASSIGNED
  IN_TRANSIT
  DELIVERED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  PAID_TO_DELIVERER
  REFUNDED
}

model Delivery {
  id                      String        @id @default(cuid())
  announcementId          String
  status                  DeliveryStatus @default(PENDING)
  startTime               DateTime?
  endTime                 DateTime?
  proof                   String?        // URL to image or document
  requiresConfirmationCode Boolean       @default(true)
  clientConfirmed         Boolean        @default(false)
  rating                  Int?           // 1-5 rating
  feedback                String?
  paymentStatus           PaymentStatus? 
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt

  // Relations
  announcement   Announcement    @relation(fields: [announcementId], references: [id])
  locationUpdates LocationUpdate[]
}

enum DeliveryStatus {
  PENDING
  IN_TRANSIT
  DELIVERED
  CANCELLED
}

model LocationUpdate {
  id          String   @id @default(cuid())
  deliveryId  String
  latitude    Float
  longitude   Float
  timestamp   DateTime @default(now())

  // Relations
  delivery    Delivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)
}

model Store {
  id          String      @id @default(cuid())
  name        String
  description String      @db.Text
  type        String      // Type of store (restaurant, grocery, etc.)
  address     String
  city        String
  postalCode  String
  phoneNumber String
  siret       String?     // French business identification number
  logoUrl     String?
  status      StoreStatus @default(PENDING)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  merchantId  String
  merchant    User        @relation(fields: [merchantId], references: [id])
}

enum StoreStatus {
  PENDING
  APPROVED
  REJECTED
}

model Service {
  id          String        @id @default(cuid())
  title       String
  description String        @db.Text
  category    ServiceCategory
  price       Float
  duration    Int           // Duration in minutes
  imageUrl    String?
  status      ServiceStatus @default(ACTIVE)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  providerId  String
  provider    User          @relation(fields: [providerId], references: [id])
  appointments Appointment[]
}

enum ServiceCategory {
  TRANSPORT
  HOUSEWORK
  SHOPPING
  OTHER
}

enum ServiceStatus {
  ACTIVE
  INACTIVE
}

model Appointment {
  id          String            @id @default(cuid())
  startTime   DateTime
  endTime     DateTime
  status      AppointmentStatus @default(SCHEDULED)
  notes       String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  // Relations
  clientId     String
  client       User             @relation("ClientAppointments", fields: [clientId], references: [id])
  providerId   String
  provider     User             @relation("ProviderAppointments", fields: [providerId], references: [id])
  serviceId    String
  service      Service          @relation(fields: [serviceId], references: [id])
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  COMPLETED
  CANCELLED
}

model Payment {
  id          String       @id @default(cuid())
  amount      Float
  type        PaymentType
  status      PaymentStatus
  externalId  String?      // For Stripe, etc.
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  announcementId String?
  announcement   Announcement? @relation(fields: [announcementId], references: [id])
  invoiceId      String?
  invoice        Invoice?     @relation(fields: [invoiceId], references: [id])
  
  @@index([invoiceId])
}

enum PaymentType {
  ANNOUNCEMENT
  SUBSCRIPTION
  SERVICE
  INVOICE
}

model ClientProfile {
  id             String    @id @default(cuid())
  userId         String    @unique
  address        String?
  phoneNumber    String?
  preferences    Json?
  
  // Relations
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription   Subscription?
}

model DelivererProfile {
  id                  String    @id @default(cuid())
  userId              String    @unique
  idCard              String?   // URL to ID card image
  driversLicense      String?   // URL to driver's license image
  vehicleType         String?
  vehiclePlate        String?
  bankAccount         String?
  backgroundCheckDate DateTime?
  isVerified          Boolean   @default(false)
  rating              Float?    // Average rating
  totalDeliveries     Int       @default(0)
  
  // Relations
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ServiceProvider {
  id                  String    @id @default(cuid())
  userId              String    @unique
  businessName        String?
  businessAddress     String?
  siret               String?   // French business ID
  specialties         String[]
  certifications      String[]
  bankAccount         String?
  backgroundCheckDate DateTime?
  isVerified          Boolean   @default(false)
  rating              Float?    // Average rating
  
  // Relations
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Models for subscription plans
model SubscriptionPlan {
  id                     String         @id @default(cuid())
  name                   String
  description            String         @db.Text
  price                  Float
  features               String[]
  insuranceCoverage      Float          // Maximum amount covered by insurance
  shippingDiscount       Float          // Percentage discount on shipping
  priorityShippingDiscount Float        // Percentage discount on priority shipping
  permanentDiscount      Float          // Permanent discount on all shipments
  freeShipments          Int            // Number of free shipments per month
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  
  // Relations
  subscriptions          Subscription[]
}

model Subscription {
  id                String             @id @default(cuid())
  planId            String
  clientProfileId   String             @unique
  startDate         DateTime
  endDate           DateTime
  status            SubscriptionStatus @default(ACTIVE)
  stripeSubscriptionId String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  // Relations
  plan              SubscriptionPlan   @relation(fields: [planId], references: [id])
  clientProfile     ClientProfile      @relation(fields: [clientProfileId], references: [id])
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

// Model for warehouse/storage management
model Warehouse {
  id          String    @id @default(cuid())
  name        String
  address     String
  city        String
  postalCode  String
  country     String
  capacity    Int       // Total capacity in cubic meters
  usedSpace   Int       @default(0) // Used space in cubic meters
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  storageUnits StorageUnit[]
}

model StorageUnit {
  id           String         @id @default(cuid())
  warehouseId  String
  code         String         // Unique code for the storage unit
  size         Float          // Size in cubic meters
  status       StorageStatus  @default(AVAILABLE)
  price        Float          // Price per day
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  
  // Relations
  warehouse    Warehouse      @relation(fields: [warehouseId], references: [id])
  rentals      StorageRental[]
}

enum StorageStatus {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
}

model StorageRental {
  id             String    @id @default(cuid())
  storageUnitId  String
  userId         String
  startDate      DateTime
  endDate        DateTime?
  status         RentalStatus @default(ACTIVE)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  
  // Relations
  storageUnit    StorageUnit @relation(fields: [storageUnitId], references: [id])
  user           User        @relation(fields: [userId], references: [id])
}

enum RentalStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}

// Models for localization/multi-language support
model Language {
  id          String   @id @default(cuid())
  code        String   @unique  // e.g., 'en', 'fr', 'es'
  name        String   // e.g., 'English', 'Français', 'Español'
  isDefault   Boolean  @default(false)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  translations Translation[]
}

model Translation {
  id          String   @id @default(cuid())
  languageId  String
  key         String   // Translation key, e.g., 'app.welcome', 'nav.home'
  value       String   // Translated text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  language    Language @relation(fields: [languageId], references: [id], onDelete: Cascade)
  
  @@unique([languageId, key])
}

// Models for tutorial/onboarding
model TutorialStep {
  id          String   @id @default(cuid())
  title       String
  description String   @db.Text
  element     String?  // CSS selector or element ID to highlight
  order       Int      // Ordering of steps
  userTypes   String[] // Which user types this step applies to ('ALL', 'CLIENT', etc.)
  imageUrl    String?  // Optional image to display with the step
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model TutorialProgress {
  id          String   @id @default(cuid())
  userId      String   @unique
  currentStep Int      @default(0)
  completed   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Models for notifications
model Notification {
  id          String   @id @default(cuid())
  userId      String
  title       String
  body        String
  type        NotificationType
  isRead      Boolean  @default(false)
  data        Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum NotificationType {
  ANNOUNCEMENT
  DELIVERY
  MESSAGE
  SYSTEM
}

model NotificationPreference {
  id            String   @id @default(cuid())
  userId        String   @unique
  email         Boolean  @default(true)
  push          Boolean  @default(true)
  announcements Boolean  @default(true)
  deliveries    Boolean  @default(true)
  messages      Boolean  @default(true)
  marketing     Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PushSubscription {
  id           String   @id @default(cuid())
  userId       String
  token        String   @unique
  platform     PushPlatform
  lastActiveAt DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  // Relations
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum PushPlatform {
  WEB
  IOS
  ANDROID
}

model Invoice {
  id            String       @id @default(cuid())
  invoiceNumber String       @unique
  status        InvoiceStatus
  merchantId    String?
  merchant      User?        @relation("MerchantInvoices", fields: [merchantId], references: [id])
  providerId    String?
  provider      User?        @relation("ProviderInvoices", fields: [providerId], references: [id])
  subtotal      Float
  taxAmount     Float
  total         Float
  dueDate       DateTime
  paidAt        DateTime?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  notes         String?
  invoiceItems  InvoiceItem[]
  payments      Payment[]

  @@index([merchantId])
  @@index([providerId])
  @@index([status])
  @@index([dueDate])
}

model InvoiceItem {
  id          String    @id @default(cuid())
  invoiceId   String
  invoice     Invoice   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  description String
  quantity    Float
  unitPrice   Float
  taxRate     Float
  total       Float
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([invoiceId])
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
}
