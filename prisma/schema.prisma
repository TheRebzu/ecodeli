// Ce fichier est généré automatiquement à partir des fichiers fragmentés dans /prisma/schemas/
// Ne pas modifier directement - éditer les fichiers sources puis reconstruire

generator client {
  provider      = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Import schémas du domaine shared
// Import schémas du domaine users
// Import schémas du domaine client
// Import schémas du domaine deliveries
// Import schémas du domaine services
// Import schémas du domaine appointments
// Import schémas du domaine storage
// Import schémas du domaine payments
// Import schémas du domaine billing
// Import schémas du domaine merchant
// Import schémas du domaine admin
// Import schémas du domaine messages


// ----- DOMAINE: SHARED -----

// ===== ENUMS PARTAGÉS =====

// ===== DOMAINE UTILISATEURS =====

/// Type de rôle utilisateur dans le système
enum UserRole {
  CLIENT     // Utilisateur standard qui requiert des services
  DELIVERER  // Livreur qui effectue les livraisons
  MERCHANT   // Commerçant qui propose des produits
  PROVIDER   // Prestataire qui offre des services
  ADMIN      // Administrateur de la plateforme
}

/// Statut du compte utilisateur
enum UserStatus {
  PENDING_VERIFICATION // En attente de vérification
  ACTIVE               // Compte actif
  SUSPENDED            // Compte temporairement suspendu
  INACTIVE             // Compte inactif
}

/// Type de document d'identification
enum DocumentType {
  ID_CARD            // Carte d'identité
  PASSPORT           // Passeport
  DRIVERS_LICENSE    // Permis de conduire
  PROOF_OF_ADDRESS   // Justificatif de domicile
  VEHICLE_INSURANCE  // Assurance véhicule
  VEHICLE_REGISTRATION // Carte grise
  BUSINESS_LICENSE   // Licence commerciale
  INSURANCE_CERTIFICATE // Certificat d'assurance
  PROFESSIONAL_QUALIFICATION // Qualification professionnelle
  TAX_CERTIFICATE    // Certificat fiscal
  BUSINESS_REGISTRATION // Enregistrement entreprise
  VAT_REGISTRATION   // Enregistrement TVA
  OTHER              // Autre type de document
}

/// Statut d'un document
enum DocumentStatus {
  PENDING   // En attente de vérification
  APPROVED  // Document approuvé
  REJECTED  // Document rejeté
  EXPIRED   // Document expiré
}

/// Statut de vérification
enum VerificationStatus {
  PENDING    // En attente d'examen
  APPROVED   // Vérifié et approuvé
  REJECTED   // Rejeté pour non-conformité
}

/// Type de token d'authentification
enum TokenType {
  EMAIL_VERIFICATION // Vérification d'email
  PASSWORD_RESET     // Réinitialisation de mot de passe
  TWO_FACTOR_AUTH    // Authentification à deux facteurs
}

/// Type d'activité utilisateur pour le journal d'audit
enum ActivityType {
  LOGIN               // Connexion
  LOGOUT              // Déconnexion
  PROFILE_UPDATE      // Mise à jour du profil
  PASSWORD_CHANGE     // Changement de mot de passe
  STATUS_CHANGE       // Changement de statut
  ROLE_CHANGE         // Changement de rôle
  VERIFICATION_SUBMIT // Soumission de vérification
  VERIFICATION_REVIEW // Révision de vérification
  DOCUMENT_UPLOAD     // Téléversement de document
  ACCOUNT_CREATION    // Création de compte
  OTHER               // Autre activité
}

// ===== DOMAINE LIVRAISONS =====

/// Statut d'une annonce de livraison
enum AnnouncementStatus {
  DRAFT        // Brouillon
  PUBLISHED    // Publiée
  IN_APPLICATION // En cours de candidature
  ASSIGNED     // Assignée
  IN_PROGRESS  // En cours
  DELIVERED    // Livrée
  COMPLETED    // Terminée
  PAID         // Payée
  PROBLEM      // Problème
  DISPUTE      // Litige
  CANCELLED    // Annulée
}

/// Type d'annonce
enum AnnouncementType {
  PACKAGE_DELIVERY   // Livraison de colis
  PARTIAL_DELIVERY   // Livraison partielle (livreur prend en charge une partie du trajet)
  FINAL_DISTRIBUTION // Distribution finale (livraison des marchandises déjà livrées)
  CART_DROP          // Lâcher de chariot (livraison depuis un commerçant partenaire)
  GROCERY_SHOPPING   // Courses alimentaires
  PERSON_TRANSPORT   // Transport de personnes
  AIRPORT_TRANSFER   // Transfert aéroport
  FOREIGN_PURCHASE   // Achat à l'étranger
  PET_CARE           // Garde d'animaux
  HOME_SERVICES      // Services à domicile
}

/// Priorité d'une annonce
enum AnnouncementPriority {
  LOW     // Basse
  MEDIUM  // Moyenne
  HIGH    // Haute
  URGENT  // Urgente
}

/// Statut d'une livraison
enum DeliveryStatus {
  PENDING   // En attente
  ACCEPTED  // Acceptée
  PICKED_UP // Récupérée
  IN_TRANSIT // En transit
  DELIVERED // Livrée
  CONFIRMED // Confirmée
  CANCELLED // Annulée
  DISPUTED  // Contestée
}

/// Statut détaillé d'une livraison (modèle plus complet)
enum DeliveryStatusEnum {
  CREATED          // Créée
  ASSIGNED         // Assignée
  PENDING_PICKUP   // En attente de récupération
  PICKED_UP        // Récupérée
  IN_TRANSIT       // En transit
  NEARBY           // À proximité
  ARRIVED          // Arrivée
  ATTEMPT_DELIVERY // Tentative de livraison
  DELIVERED        // Livrée
  NOT_DELIVERED    // Non livrée
  RESCHEDULED      // Reprogrammée
  RETURNED         // Retournée
  CANCELLED        // Annulée
}

/// Type de point de contrôle pour le suivi
enum CheckpointType {
  DEPARTURE        // Départ
  PICKUP           // Récupération
  WAYPOINT         // Point de passage
  DELIVERY_ATTEMPT // Tentative de livraison
  DELIVERY         // Livraison
  RETURN_POINT     // Point de retour
  WAREHOUSE        // Entrepôt
  CUSTOMS          // Douanes
  HANDOFF          // Transfert
  OTHER            // Autre
}

/// Type de problème de livraison
enum DeliveryIssueType {
  ACCESS_PROBLEM    // Problème d'accès
  ADDRESS_NOT_FOUND // Adresse non trouvée
  CUSTOMER_ABSENT   // Client absent
  DAMAGED_PACKAGE   // Colis endommagé
  DELIVERY_REFUSED  // Livraison refusée
  VEHICLE_BREAKDOWN // Panne de véhicule
  TRAFFIC_JAM       // Embouteillage
  WEATHER_CONDITION // Condition météorologique
  SECURITY_ISSUE    // Problème de sécurité
  OTHER             // Autre problème
}

/// Gravité d'un problème
enum IssueSeverity {
  LOW      // Basse
  MEDIUM   // Moyenne
  HIGH     // Haute
  CRITICAL // Critique
}

/// Statut d'un problème
enum IssueStatus {
  OPEN        // Ouvert
  IN_PROGRESS // En cours
  RESOLVED    // Résolu
  ESCALATED   // Escaladé
  CLOSED      // Fermé
}

/// Type d'adresse
enum AddressType {
  PICKUP   // Récupération
  DELIVERY // Livraison
  WAYPOINT // Point de passage
}

/// Type de colis
enum PackageType {
  STANDARD     // Standard
  FRAGILE      // Fragile
  REFRIGERATED // Réfrigéré
  OVERSIZED    // Surdimensionné
  DOCUMENTS    // Documents
  FOOD         // Nourriture
  ELECTRONICS  // Électronique
}

/// Statut d'une candidature
enum ApplicationStatus {
  PENDING   // En attente
  ACCEPTED  // Acceptée
  REJECTED  // Rejetée
  CANCELLED // Annulée
}

// ===== DOMAINE STOCKAGE =====

/// Type de box de stockage
enum BoxType {
  STANDARD           // Standard
  CLIMATE_CONTROLLED // Contrôle climatique
  SECURE             // Sécurisé
  EXTRA_LARGE        // Très large
  REFRIGERATED       // Réfrigéré
  FRAGILE            // Pour objets fragiles
}

/// Statut d'une box
enum BoxStatus {
  AVAILABLE   // Disponible
  RESERVED    // Réservée
  OCCUPIED    // Occupée
  MAINTENANCE // En maintenance
  DAMAGED     // Endommagée
  INACTIVE    // Inactive
}

/// Type d'action sur une box
enum BoxActionType {
  RESERVATION_CREATED   // Réservation créée
  RESERVATION_UPDATED   // Réservation mise à jour
  RESERVATION_CANCELLED // Réservation annulée
  BOX_ACCESSED          // Box accédée
  BOX_CLOSED            // Box fermée
  PAYMENT_PROCESSED     // Paiement traité
  EXTENDED_RENTAL       // Location prolongée
  INSPECTION_COMPLETED  // Inspection terminée
}

/// Statut d'une réservation
enum ReservationStatus {
  PENDING   // En attente
  ACTIVE    // Active
  COMPLETED // Terminée
  CANCELLED // Annulée
  OVERDUE   // En retard
  EXTENDED  // Prolongée
}

// ===== DOMAINE SERVICES =====

/// Statut d'une réservation de service
enum BookingStatus {
  PENDING     // En attente
  CONFIRMED   // Confirmée
  COMPLETED   // Terminée
  CANCELLED   // Annulée
  RESCHEDULED // Reprogrammée
}

/// Statut d'un contrat
enum ContractStatus {
  DRAFT             // Brouillon
  PENDING_SIGNATURE // En attente de signature
  ACTIVE            // Actif
  SUSPENDED         // Suspendu
  TERMINATED        // Résilié
  EXPIRED           // Expiré
  CANCELLED         // Annulé

  @@map("ContractStatus")
}

/// Type de contrat
enum ContractType {
  STANDARD      // Contrat standard
  PREMIUM       // Contrat premium avec avantages
  PARTNER       // Contrat partenaire privilégié
  TRIAL         // Contrat d'essai
  CUSTOM        // Contrat personnalisé

  @@map("ContractType")
}

/// Type de service
enum ServiceType {
  DELIVERY // Livraison
  SERVICE  // Service
  STORAGE  // Stockage
  CUSTOM   // Personnalisé
}

/// Type d'exception de disponibilité
enum ExceptionType {
  VACATION      // Congés
  SICK_LEAVE    // Arrêt maladie
  UNAVAILABLE   // Indisponible
  MAINTENANCE   // Maintenance
  EMERGENCY     // Urgence
  PERSONAL      // Personnel
  CLOSED        // Fermé
}

// ===== DOMAINE FINANCIER =====

/// Statut de paiement
enum PaymentStatus {
  PENDING     // En attente
  PROCESSING  // En cours de traitement
  COMPLETED   // Terminé
  FAILED      // Échoué
  REFUNDED    // Remboursé
  CANCELLED   // Annulé
}

/// Type de transaction
enum TransactionType {
  DEPOSIT              // Dépôt
  WITHDRAWAL           // Retrait
  TRANSFER             // Transfert
  EARNING              // Gain
  REFUND               // Remboursement
  PLATFORM_FEE         // Frais de plateforme
  COMMISSION           // Commission
  BONUS                // Bonus
  ADJUSTMENT           // Ajustement
  TAX                  // Taxe
  SERVICE_FEE          // Frais de service
  DELIVERY_PAYOUT      // Paiement de livraison
  SERVICE_PAYOUT       // Paiement de service
  SUBSCRIPTION_PAYMENT // Paiement d'abonnement
  MONTHLY_FEE          // Frais mensuels
}

/// Statut d'une transaction
enum TransactionStatus {
  PENDING    // En attente
  PROCESSING // En cours de traitement
  COMPLETED  // Terminée
  FAILED     // Échouée
  CANCELLED  // Annulée
  DISPUTED   // Contestée
  REFUNDED   // Remboursée
}

/// Statut d'un retrait
enum WithdrawalStatus {
  PENDING    // En attente
  PROCESSING // En cours de traitement
  COMPLETED  // Terminé
  FAILED     // Échoué
  CANCELLED  // Annulé
  REJECTED   // Rejeté
  SCHEDULED  // Programmé
}

/// Statut d'un abonnement
enum SubscriptionStatus {
  ACTIVE    // Actif
  CANCELLED // Annulé
  PAST_DUE  // En retard
  TRIALING  // En période d'essai
  UNPAID    // Non payé
}

/// Type de plan d'abonnement
enum PlanType {
  FREE     // Gratuit
  STARTER  // Débutant
  PREMIUM  // Premium
  CUSTOM   // Personnalisé
}

/// Statut d'une facture
enum InvoiceStatus {
  DRAFT    // Brouillon
  ISSUED   // Émise
  PAID     // Payée
  OVERDUE  // En retard
  CANCELLED // Annulée
}

/// Priorité d'une tâche financière
enum FinancialTaskPriority {
  LOW    // Basse
  MEDIUM // Moyenne
  HIGH   // Haute
}

/// Catégorie d'une tâche financière
enum FinancialTaskCategory {
  PAYMENT    // Paiement
  INVOICE    // Facture
  WITHDRAWAL // Retrait
  OTHER      // Autre
}

/// Statut d'une commission
enum CommissionStatus {
  PENDING   // En attente
  PROCESSED // Traitée
  FAILED    // Échouée
  INVOICED  // Facturée
  ACTIVE    // Active
}

/// Intervalle de temps
enum Interval {
  DAY   // Jour
  WEEK  // Semaine
  MONTH // Mois
  YEAR  // Année
}

/// Raisons de rejet pour les documents de vérification
enum RejectionReason {
  UNREADABLE         // Document illisible
  EXPIRED            // Document expiré
  INCOMPLETE         // Informations manquantes
  FAKE               // Document potentiellement falsifié
  WRONG_TYPE         // Mauvais type de document
  LOW_QUALITY        // Qualité d'image insuffisante
  INFORMATION_MISMATCH // Informations ne correspondent pas
  OTHER              // Autre raison
}

// ===== DOMAINE RENDEZ-VOUS =====

/// Statut d'un rendez-vous
enum AppointmentStatus {
  PENDING      // En attente de confirmation
  CONFIRMED    // Confirmé par le prestataire
  RESCHEDULED  // Reprogrammé
  IN_PROGRESS  // En cours
  COMPLETED    // Terminé
  CANCELLED    // Annulé
  NO_SHOW      // Client absent
  PROVIDER_ABSENT // Prestataire absent
}

/// Raison de reprogrammation d'un rendez-vous
enum RescheduleReason {
  CLIENT_REQUEST    // Demande du client
  PROVIDER_REQUEST  // Demande du prestataire
  WEATHER_CONDITION // Conditions météorologiques
  EMERGENCY         // Urgence
  ILLNESS           // Maladie
  TECHNICAL_ISSUE   // Problème technique
  TRAFFIC_DELAY     // Retard de circulation
  DOUBLE_BOOKING    // Double réservation
  LOCATION_ISSUE    // Problème de lieu
  OTHER            // Autre raison
}

/// Raison d'annulation d'un rendez-vous
enum CancellationReason {
  CLIENT_CANCELLED     // Annulation client
  PROVIDER_CANCELLED   // Annulation prestataire
  SYSTEM_CANCELLED     // Annulation système
  NO_PAYMENT          // Défaut de paiement
  SERVICE_UNAVAILABLE // Service indisponible
  LOCATION_INACCESSIBLE // Lieu inaccessible
  WEATHER_CONDITION   // Conditions météorologiques
  EMERGENCY           // Urgence
  ILLNESS             // Maladie
  MUTUAL_AGREEMENT    // Accord mutuel
  POLICY_VIOLATION    // Violation des conditions
  OTHER              // Autre raison
}

/// Type de notification pour les rendez-vous
enum AppointmentNotificationType {
  REMINDER_24H     // Rappel 24h avant
  REMINDER_2H      // Rappel 2h avant
  REMINDER_30MIN   // Rappel 30min avant
  CONFIRMATION     // Confirmation du rendez-vous
  RESCHEDULE       // Notification de reprogrammation
  CANCELLATION     // Notification d'annulation
  PROVIDER_EN_ROUTE // Prestataire en route
  ARRIVAL          // Arrivée du prestataire
  COMPLETION       // Fin du rendez-vous
}

// ===== ENUMS MANQUANTS POUR DELIVERIES =====

/// Statut de vérification de document
enum DocumentVerificationStatus {
  PENDING    // En attente de vérification
  APPROVED   // Approuvé
  REJECTED   // Rejeté
  EXPIRED    // Expiré
}

/// Type de document requis
enum RequiredDocumentType {
  IDENTITY         // Pièce d'identité
  DRIVING_LICENSE  // Permis de conduire
  INSURANCE        // Assurance
  VEHICLE_REGISTRATION // Carte grise
  BANK_RIB         // RIB bancaire
  BUSINESS_LICENSE // Licence commerciale
  OTHER            // Autre
}

/// Type de véhicule
enum VehicleType {
  CAR        // Voiture
  MOTORCYCLE // Moto
  BICYCLE    // Vélo
  SCOOTER    // Scooter
  VAN        // Camionnette
  TRUCK      // Camion
  FOOT       // À pied
  OTHER      // Autre
}

/// Niveau d'urgence
enum UrgencyLevel {
  LOW     // Faible
  NORMAL  // Normal
  HIGH    // Élevé
  URGENT  // Urgent
}

/// Genre
enum Gender {
  MALE    // Homme
  FEMALE  // Femme
  OTHER   // Autre
  NO_PREFERENCE // Aucune préférence
}

/// Statut de matching
enum MatchingStatus {
  SUGGESTED  // Suggéré
  ACCEPTED   // Accepté
  REJECTED   // Rejeté
  EXPIRED    // Expiré
}

/// Type de notification
enum NotificationType {
  INFO     // Information
  WARNING  // Avertissement
  ERROR    // Erreur
  SUCCESS  // Succès
  REMINDER // Rappel
  ALERT    // Alerte
}

/// Statut de notification
enum NotificationStatus {
  PENDING   // En attente
  SENT      // Envoyée
  DELIVERED // Délivrée
  READ      // Lue
  FAILED    // Échec
}

// ===== NOUVEAUX ENUMS POUR LE CAHIER DES CHARGES =====

/// Type de plan d'abonnement client EcoDeli
enum ClientSubscriptionPlan {
  FREE     // Gratuit : Pas d'assurance, pas de réduction
  STARTER  // Starter (9,90€/mois) : Assurance 115€, 5% réduction, prioritaire +15%
  PREMIUM  // Premium (19,99€/mois) : Assurance 3000€, 9% réduction, 1er envoi offert, 3 prioritaires/mois gratuits
}

/// Type de service à la personne
enum PersonalServiceType {
  PERSON_TRANSPORT     // Transport de personnes (médecin, gare, travail)
  AIRPORT_TRANSFER     // Transfert aéroport
  GROCERY_SHOPPING     // Courses avec liste fournie
  INTERNATIONAL_PURCHASE // Achats à l'étranger (ex: Jelly UK, cuberdons Belgique)
  PET_SITTING          // Garde animaux pendant transport
  HOME_SERVICES        // Petits travaux ménagers/jardinage
  OTHER                // Autre service
}

/// Statut d'habilitation prestataire
enum HabilitationStatus {
  PENDING     // En attente
  APPROVED    // Approuvée
  REJECTED    // Rejetée
  EXPIRED     // Expirée
  SUSPENDED   // Suspendue
}

/// Type d'intervention prestataire
enum InterventionType {
  SCHEDULED   // Planifiée
  EMERGENCY   // Urgence
  RECURRING   // Récurrente
  ONE_TIME    // Ponctuelle
}

/// Statut d'une intervention
enum InterventionStatus {
  SCHEDULED   // Planifiée
  IN_PROGRESS // En cours
  COMPLETED   // Terminée
  CANCELLED   // Annulée
  POSTPONED   // Reportée
}

/// Type d'évaluation
enum EvaluationType {
  CLIENT_TO_PROVIDER  // Client vers prestataire
  PROVIDER_TO_CLIENT  // Prestataire vers client
  ADMIN_REVIEW        // Évaluation admin
}

/// Statut de facturation automatique
enum AutoInvoicingStatus {
  ENABLED     // Activée
  DISABLED    // Désactivée
  SUSPENDED   // Suspendue
  PENDING     // En attente
}

/// Type de KPI plateforme
enum KpiType {
  REVENUE       // Chiffre d'affaires
  USER_COUNT    // Nombre d'utilisateurs
  DELIVERY_COUNT // Nombre de livraisons
  CONVERSION    // Taux de conversion
  SATISFACTION  // Satisfaction client
  PERFORMANCE   // Performance
}

/// Type de statistique multi-sites
enum SiteStatsType {
  PARIS       // Entrepôt Paris
  MARSEILLE   // Entrepôt Marseille
  LYON        // Entrepôt Lyon
  LILLE       // Entrepôt Lille
  MONTPELLIER // Entrepôt Montpellier
  RENNES      // Entrepôt Rennes
}

/// Type de prévision financière
enum ForecastType {
  MONTHLY     // Mensuelle
  QUARTERLY   // Trimestrielle
  YEARLY      // Annuelle
  CUSTOM      // Personnalisée
}

/// Statut de route planifiée
enum PlannedRouteStatus {
  DRAFT       // Brouillon
  PUBLISHED   // Publiée
  ACTIVE      // Active
  COMPLETED   // Terminée
  CANCELLED   // Annulée
}

/// Type de lâcher de chariot
enum CartDropType {
  INSTANT     // Immédiat
  SCHEDULED   // Planifié
  RECURRING   // Récurrent
}

/// Statut de lâcher de chariot
enum CartDropStatus {
  PENDING     // En attente
  CONFIRMED   // Confirmé
  IN_PROGRESS // En cours
  DELIVERED   // Livré
  CANCELLED   // Annulé
} 
// ===== SYSTÈME DE TUTORIELS =====

/// Type de tutoriel
enum TutorialType {
  ONBOARDING    // Tutoriel d'accueil
  FEATURE_GUIDE // Guide de fonctionnalité
  OVERLAY       // Tutoriel en superposition
  INTERACTIVE   // Tutoriel interactif
  VIDEO         // Tutoriel vidéo
  WALKTHROUGH   // Parcours guidé
}

/// Statut d'un tutoriel
enum TutorialStatus {
  DRAFT      // Brouillon
  PUBLISHED  // Publié
  ARCHIVED   // Archivé
  DISABLED   // Désactivé
}

/// Type de contenu d'étape
enum StepContentType {
  TEXT     // Texte simple
  HTML     // HTML enrichi
  VIDEO    // Vidéo
  IMAGE    // Image
  OVERLAY  // Superposition
  TOOLTIP  // Info-bulle
  MODAL    // Modal
  HIGHLIGHT // Surbrillance d'élément
}

/// Type d'action attendue
enum StepActionType {
  CLICK       // Cliquer
  HOVER       // Survol
  INPUT       // Saisie
  SCROLL      // Défilement
  NAVIGATE    // Navigation
  WAIT        // Attendre
  COMPLETE    // Terminer
  SKIP        // Passer
}

/// Statut de progression
enum ProgressStatus {
  NOT_STARTED // Non commencé
  IN_PROGRESS // En cours
  COMPLETED   // Terminé
  SKIPPED     // Ignoré
  ABANDONED   // Abandonné
}

/// Modèle de tutoriel
model Tutorial {
  id          String        @id @default(cuid())
  title       String        // Titre du tutoriel
  description String?       // Description
  type        TutorialType  @default(ONBOARDING)
  status      TutorialStatus @default(DRAFT)
  targetRole  UserRole?     // Rôle ciblé (optionnel, pour tous si null)
  
  // Configuration
  isRequired  Boolean       @default(false) // Tutoriel obligatoire
  priority    Int           @default(0)     // Ordre de priorité
  
  // Conditions d'affichage
  showOnLogin Boolean       @default(false) // Afficher à la connexion
  showOnPage  String?       // Page spécifique où afficher
  triggerEvent String?      // Événement qui déclenche le tutoriel
  
  // Métadonnées
  version     String        @default("1.0")
  language    String        @default("fr")
  estimatedDuration Int?    // Durée estimée en minutes
  
  // Relations
  steps       TutorialStep[]
  progress    TutorialProgress[]
  
  // Audit
  createdBy   String?
  creator     User?         @relation("TutorialCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@map("tutorials")
}

/// Modèle d'étape de tutoriel
model TutorialStep {
  id          String          @id @default(cuid())
  tutorialId  String
  stepNumber  Int             // Ordre de l'étape
  title       String          // Titre de l'étape
  content     String          // Contenu de l'étape
  contentType StepContentType @default(TEXT)
  
  // Configuration d'affichage
  targetElement String?       // Sélecteur CSS de l'élément ciblé
  position      String?       // Position (top, bottom, left, right)
  width         Int?          // Largeur en pixels
  height        Int?          // Hauteur en pixels
  
  // Action attendue
  actionType    StepActionType? // Type d'action attendue
  actionTarget  String?        // Élément sur lequel agir
  actionValue   String?        // Valeur à saisir (pour INPUT)
  
  // Configuration comportementale
  isSkippable   Boolean        @default(true)  // Peut être ignorée
  autoAdvance   Boolean        @default(false) // Avancement automatique
  duration      Int?           // Durée d'affichage (en ms)
  
  // Validation
  validationRule String?       // Règle de validation JavaScript
  errorMessage   String?       // Message d'erreur si validation échoue
  
  // Relations
  tutorial    Tutorial @relation(fields: [tutorialId], references: [id], onDelete: Cascade)
  completions TutorialStepCompletion[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([tutorialId, stepNumber])
  @@map("tutorial_steps")
}

/// Modèle de progression dans un tutoriel
model TutorialProgress {
  id          String         @id @default(cuid())
  userId      String
  tutorialId  String
  status      ProgressStatus @default(NOT_STARTED)
  
  // Progression
  currentStep Int            @default(0) // Étape actuelle (0 = non commencé)
  totalSteps  Int            @default(0) // Nombre total d'étapes
  
  // Timestamps
  startedAt   DateTime?      // Début du tutoriel
  completedAt DateTime?      // Fin du tutoriel
  lastViewedAt DateTime?     // Dernière consultation
  
  // Métadonnées
  timeSpent   Int            @default(0) // Temps passé en secondes
  skipCount   Int            @default(0) // Nombre d'étapes ignorées
  retryCount  Int            @default(0) // Nombre de tentatives
  
  // Relations
  user        User     @relation("TutorialProgressToUser", fields: [userId], references: [id], onDelete: Cascade)
  tutorial    Tutorial @relation(fields: [tutorialId], references: [id], onDelete: Cascade)
  stepCompletions TutorialStepCompletion[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, tutorialId])
  @@map("tutorial_progress")
}

/// Modèle de complétion d'étape
model TutorialStepCompletion {
  id             String           @id @default(cuid())
  progressId     String
  stepId         String
  stepNumber     Int              // Numéro de l'étape
  status         ProgressStatus   @default(COMPLETED)
  
  // Temps de complétion
  completedAt    DateTime         @default(now())
  timeSpent      Int              @default(0) // Temps passé sur cette étape (en secondes)
  
  // Interaction
  actionPerformed String?         // Action effectuée par l'utilisateur
  userInput      String?          // Saisie utilisateur si applicable
  
  // Métadonnées
  errorCount     Int              @default(0) // Nombre d'erreurs
  hintUsed       Boolean          @default(false) // Aide utilisée
  
  // Relations
  progress       TutorialProgress @relation(fields: [progressId], references: [id], onDelete: Cascade)
  step           TutorialStep     @relation(fields: [stepId], references: [id], onDelete: Cascade)
  
  createdAt      DateTime         @default(now())

  @@unique([progressId, stepId])
  @@map("tutorial_step_completions")
}

/// Modèle de configuration d'overlay
model OverlayConfig {
  id          String   @id @default(cuid())
  userId      String
  pagePath    String   // Chemin de la page
  isEnabled   Boolean  @default(true)
  
  // Configuration d'affichage
  overlayData Json     // Données de configuration de l'overlay
  
  // Conditions
  showOnFirstVisit Boolean @default(true)
  maxDisplayCount  Int     @default(3) // Nombre maximum d'affichages
  currentCount     Int     @default(0) // Compteur actuel
  
  // Relations
  user        User     @relation("OverlayConfigToUser", fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, pagePath])
  @@map("overlay_configs")
}
// ===== TYPES PARTAGÉS =====
// Ce fichier est réservé aux types communs qui seront utilisés par plusieurs domaines.
// Par exemple des définitions de types Prisma personnalisés ou des composants JSON partagés.

// Pour le moment, ce fichier reste vide car nous n'avons pas encore défini de types partagés.
// Il servira de point d'extension pour ajouter des types communs à l'avenir.

// Exemple de comment définir un type personnalisé (commenté pour l'instant):
/*
/// Type pour une coordonnée géographique
type GeoCoordinates {
  latitude  Float
  longitude Float
}
*/ 

// ----- DOMAINE: USERS -----

// ===== MODÈLES D'AUTHENTIFICATION =====
// Ces modèles gèrent les connexions, sessions et tokens d'authentification
// pour l'ensemble des utilisateurs EcoDeli.

/// Comptes externes associés à un utilisateur (OAuth)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  
  // Relation avec l'utilisateur
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

/// Sessions actives des utilisateurs
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  
  // Relation avec l'utilisateur
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

/// Tokens pour les opérations d'authentification (vérification email, reset mot de passe)
model VerificationToken {
  identifier String
  token      String    @unique
  expires    DateTime
  type       TokenType @default(EMAIL_VERIFICATION)
  used       Boolean   @default(false)

  @@unique([identifier, token])
  @@map("verification_tokens")
} 
// ===== MODÈLES DE CONTRATS =====
// Ce modèle a été déplacé dans le domaine admin
// Voir admin/contracts.prisma 
// ===== MODÈLES DE NOTIFICATIONS =====
// Ce modèle a été déplacé dans le domaine admin
// Voir admin/notifications.prisma 
// ===== MODÈLES DE PROFILS UTILISATEURS =====
// Ces modèles définissent les profils spécifiques pour chaque type d'utilisateur,
// avec leurs attributs et relations propres.

/// Profil client: utilisateur qui demande des livraisons et stockage
model Client {
  id                String    @id @default(cuid())
  userId            String    @unique
  address           String?
  phone             String?
  preferences       Json?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  city              String?
  state             String?
  postalCode        String?
  country           String?
  preferredLanguage String?
  newsletterOptIn   Boolean   @default(false)
  notificationPrefs Json?
  avatarUrl         String?
  
  // Relations
  deliveryAddresses Address[]
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("clients")
}

/// Profil livreur: utilisateur qui effectue les livraisons
model Deliverer {
  id                  String    @id @default(cuid())
  userId              String    @unique
  address             String?
  phone               String
  vehicleType         String?
  licensePlate        String?
  isVerified          Boolean   @default(false)
  availableHours      Json?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  verificationDate    DateTime?
  maxCapacity         Float?
  currentLocation     String?
  isActive            Boolean   @default(false)
  rating              Float?
  serviceZones        Json?
  bio                 String?
  yearsOfExperience   Int?
  preferredVehicle    String?
  maxWeightCapacity   Float?
  availableDays       String[]
  bankInfo            Json?
  taxIdentifier       String?
  deliveryPreferences Json?
  
  // Relations
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("deliverers")
}

/// Profil commerçant: utilisateur qui propose des produits
model Merchant {
  id               String     @id @default(cuid())
  userId           String     @unique
  companyName      String
  address          String
  phone            String
  businessType     String?
  vatNumber        String?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  businessName     String?
  businessAddress  String?
  businessCity     String?
  businessState    String?
  businessPostal   String?
  businessCountry  String?
  taxId            String?
  websiteUrl       String?
  isVerified       Boolean    @default(false)
  verificationDate DateTime?
  logoUrl          String?
  coverPhotoUrl    String?
  openingHours     Json?
  description      String?
  socialLinks      Json?
  paymentMethods   String[]
  deliveryOptions  String[]
  certifications   String[]
  foundingYear     Int?
  employeeCount    Int?
  
  // Relations
  contracts        Contract[]
  verification     MerchantVerification?
  user             User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Nouvelles relations pour le cahier des charges
  cashRegister     MerchantCashRegister?  @relation("MerchantCashRegister")
  cartDrops        CartDrop[]             @relation("MerchantCartDrops")
  cartDropGroups   CartDropGroup[]        @relation("MerchantCartDropGroups")
  deliveryZones    MerchantDeliveryZone[] @relation("MerchantDeliveryZones")

  @@map("merchants")
}

/// Profil prestataire: utilisateur qui offre des services
model Provider {
  id                 String    @id @default(cuid())
  userId             String    @unique
  companyName        String?
  address            String
  phone              String
  services           String[]
  isVerified         Boolean   @default(false)
  rating             Float?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  serviceType        String?
  description        String?
  availability       String?
  verificationDate   DateTime?
  professionalBio    String?
  serviceRadius      Int?
  portfolioUrls      String[]
  qualifications     String[]
  yearsInBusiness    Int?
  insuranceInfo      Json?
  workSchedule       Json?
  serviceFees        Json?
  cancellationPolicy String?
  languages          String[]
  
  // Relations
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  skills             Skill[]
  verification       ProviderVerification?

  @@map("providers")
}

/// Profil administrateur: utilisateur qui gère la plateforme
model Admin {
  id               String   @id @default(cuid())
  userId           String   @unique
  permissions      String[]
  department       String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  twoFactorEnabled Boolean  @default(false)
  twoFactorSecret  String?
  
  // Relations
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("admins")
}

/// Adresses de livraison associées à un client
model Address {
  id         String  @id @default(cuid())
  label      String
  street     String
  city       String
  state      String?
  postalCode String
  country    String
  isDefault  Boolean @default(false)
  clientId   String
  
  // Relations
  client       Client              @relation(fields: [clientId], references: [id], onDelete: Cascade)
  appointments ClientAppointment[] // Rendez-vous se déroulant à cette adresse

  @@map("addresses")
} 
// ===== MODÈLE UTILISATEUR PRINCIPAL =====
// Ce modèle est au cœur du système EcoDeli et représente tous les utilisateurs
// indépendamment de leur rôle (client, livreur, commerçant, prestataire, admin).

/// Utilisateur principal avec authentification et données de profil communes
model User {
  id                       String                        @id @default(cuid())
  name                     String
  email                    String                        @unique
  emailVerified            DateTime?
  password                 String
  image                    String?
  role                     UserRole
  status                   UserStatus                    @default(PENDING_VERIFICATION)
  createdAt                DateTime                      @default(now())
  updatedAt                DateTime                      @updatedAt
  phoneNumber              String?
  lastLoginAt              DateTime?
  twoFactorEnabled         Boolean                       @default(false)
  twoFactorSecret          String?
  locale                   String?
  preferences              Json?
  isVerified               Boolean                       @default(false)
  lastPasswordChange       DateTime?
  lockedUntil              DateTime?
  // Champs de bannissement
  isBanned                 Boolean                       @default(false) // Indique si l'utilisateur est banni
  bannedAt                 DateTime?                     // Date du bannissement
  bannedById               String?                       // ID de l'admin ayant banni
  banReason                String?                       // Raison du bannissement
  bannedBy                 User?                         @relation("BannedBy", fields: [bannedById], references: [id])
  loginAttempts            Int                           @default(0)
  notes                    String?
  hasCompletedOnboarding   Boolean                       @default(false)
  lastOnboardingStep       Int                           @default(0)
  onboardingCompletionDate DateTime?
  isProvider               Boolean                       @default(false)
  providerBio              String?
  providerLocationLat      Float?
  providerLocationLng      Float?
  providerAddress          String?
  providerZipCode          String?
  providerCity             String?
  providerVerified         Boolean                       @default(false)
  isActive                 Boolean                       @default(true)
  
  // Relation avec les livraisons
  clientDeliveries         Delivery[]                    @relation("ClientDeliveries")
  delivererDeliveries      Delivery[]                    @relation("DelivererDeliveries")
  
  // Relations communes
  notifications            Notification[]
  providerAvailability     ProviderAvailability[]
  providedServices         Service[]
  clientBookings           ServiceBooking[]              @relation("ClientBookings")
  providerBookings         ServiceBooking[]              @relation("ProviderBookings")
  
  // Relations d'authentification
  accounts                 Account[]
  sessions                 Session[]
  
  // Relations avec les profils spécifiques
  admin                    Admin?
  client                   Client?
  deliverer                Deliverer?
  merchant                 Merchant?
  provider                 Provider?
  
  // Relations avec les entités métier
  clientAnnouncements      Announcement[]                @relation("ClientAnnouncements")
  merchantAnnouncements    Announcement[]                @relation("MerchantAnnouncements")
  relayDelivererAnnouncements Announcement[]             @relation("RelayDelivererAnnouncements")
  delivererAnnouncements   Announcement[]                @relation("DelivererAnnouncements")
  performedAuditLogs       AuditLog[]                    @relation("AuditLogPerformer")
  boxSubscriptions         BoxAvailabilitySubscription[]
  boxUsageHistory          BoxUsageHistory[]
  boxes                    Box[]
  favorites                DelivererFavorite[]
  deliveryApplications     DeliveryApplication[]
  reviewedDocuments        Document[]                    @relation("DocumentReviewer")
  documents                Document[]
  financialTasks           FinancialTask[]
  invoices                 Invoice[]
  paymentMethods           PaymentMethod[]
  payments                 Payment[]
  reservations             Reservation[]
  subscriptions            Subscription[]
  activityLogs             UserActivityLog[]
  
  // Relations avec les évaluations
  givenRatings             DeliveryRating[]              @relation("RatingGiver")
  receivedRatings          DeliveryRating[]              @relation("RatingReceiver")
  
  // Relations avec les vérifications
  verificationHistory      VerificationHistory[]
  verifiedHistories        VerificationHistory[]         @relation("VerifierRelation")
  submittedVerifications   Verification[]                @relation("SubmitterRelation")
  verifications            Verification[]                @relation("VerifierRelation")
  
  // Relation avec le portefeuille
  wallet                   Wallet?
  
  // Relations avec la messagerie
  sentMessages             Message[]

  // Relations avec les rendez-vous
  clientAppointments       ClientAppointment[]           @relation("ClientAppointments")
  providerAppointments     ClientAppointment[]           @relation("ProviderAppointments")
  appointmentHistory       AppointmentHistory[]          @relation("AppointmentHistoryUser")
  appointmentNotifications AppointmentNotification[]     @relation("AppointmentNotificationUser")
  providerSlots            AppointmentSlot[]             @relation("ProviderAppointmentSlots")
  reservedSlots            AppointmentSlot[]             @relation("ClientReservedSlots")
  availabilityRules        AppointmentAvailabilityRule[] @relation("ProviderAvailabilityRules")
  availabilityExceptions   AppointmentAvailabilityException[] @relation("ProviderAvailabilityExceptions")
  bannedUsers              User[]                        @relation("BannedBy")

  // Relations avec les livreurs
  delivererSchedules       DelivererSchedule[]           @relation("DelivererSchedules")
  delivererRoutes          DelivererRoute[]              @relation("DelivererRoutes")
  delivererServiceRoutes   DelivererServiceRoute[]       @relation("DelivererServiceRoutes")
  delivererAvailabilities  DelivererAvailability[]       @relation("DelivererAvailabilities")
  delivererStats           DelivererStats[]              @relation("DelivererStats")
  verifiedApplications     DeliveryApplication[]         @relation("ApplicationVerifier")
  verifiedDocuments        ApplicationDocument[]         @relation("DocumentVerifier")
  delivererPreferences     DelivererPreferences[]        @relation("DelivererPreferences")
  validationAudits         DocumentValidationAudit[]     @relation("ValidationActor")
  matchings                AnnouncementMatching[]        @relation("DelivererMatchings")
  delivererNotifications   DelivererNotification[]       @relation("DelivererNotifications")
  
  // Relations avec les prestataires et merchants
  merchantVerifications    MerchantVerification[]        @relation("MerchantVerifier")
  providerVerifications    ProviderVerification[]        @relation("ProviderVerifier")
  signedContracts          Contract[]                    @relation("ContractSignedBy")
  createdTemplates         ContractTemplate[]
  signedAmendments         ContractAmendment[]
  initiatedNegotiations    ContractNegotiation[]         @relation("NegotiationInitiator")
  respondedNegotiations    ContractNegotiation[]         @relation("NegotiationResponder")
  providerExceptions       ProviderException[]
  providerSpecialSlots     ProviderSpecialSlot[]

  // ===== NOUVELLES RELATIONS POUR LE CAHIER DES CHARGES =====
  
  // Relations routes planifiées
  plannedRoutes            DelivererPlannedRoute[]   @relation("DelivererPlannedRouteToDeliverer")
  routeOptimizations       RouteOptimization[]       @relation("RouteOptimization")
  assignedCartDrops        CartDrop[]                @relation("CartDropDeliverer")
  assignedCartDropGroups   CartDropGroup[]           @relation("CartDropGroupDeliverer")
  cartDropOrders           CartDrop[]                @relation("CartDropCustomer")
  
  // Relations abonnements clients
  clientSubscription       ClientSubscriptionDetail? @relation("ClientSubscription")
  
  // Relations services personnels
  personalServicesProvided PersonalService[]         @relation("PersonalServiceProvider")
  personalServicesApproved PersonalService[]         @relation("PersonalServiceApprover")
  personalServiceBookings  PersonalServiceBooking[]  @relation("PersonalServiceClient")
  personalServiceReviews   PersonalServiceReview[]   @relation("PersonalServiceReviewer")
  personalServiceReviewed  PersonalServiceReview[]   @relation("PersonalServiceReviewed")
  personalServiceModerated PersonalServiceReview[]   @relation("PersonalServiceModerator")
  
  // Relations habilitations prestataires
  providerHabilitations    ProviderHabilitation[]    @relation("ProviderHabilitations")
  habilitationValidations  ProviderHabilitation[]    @relation("HabilitationValidator")
  providerInterventions    ProviderIntervention[]    @relation("ProviderInterventions")
  providerEvaluations      ProviderEvaluation[]      @relation("ProviderEvaluated")
  providerEvaluationsGiven ProviderEvaluation[]      @relation("ProviderEvaluator")
  evaluationModerations    ProviderEvaluation[]      @relation("EvaluationModerator")
  
  // Relations facturation automatique
  autoInvoicing            ProviderAutoInvoicing?    @relation("ProviderAutoInvoicing")
  monthlyInvoices          ProviderMonthlyInvoice[]  @relation("ProviderMonthlyInvoices")
  
  // Relations KPIs et monitoring
  createdForecasts         FinancialForecast[]       @relation("ForecastCreator")
  createdAlerts            AlertConfiguration[]      @relation("AlertCreator")
  resolvedAlerts           AlertTrigger[]            @relation("AlertResolver")
  
  // Relations tutoriels
  createdTutorials         Tutorial[]                @relation("TutorialCreator")
  tutorialProgress         TutorialProgress[]        @relation("TutorialProgressToUser")
  overlayConfigs           OverlayConfig[]           @relation("OverlayConfigToUser")
  
  // Relations cartes NFC
  nfcCards                 NFCCard[]                 @relation("NFCCardToDeliverer")
  nfcAssignments           NFCCardAssignment[]       @relation("NFCAssignmentToDeliverer")
  nfcAssignedByAdmin       NFCCardAssignment[]       @relation("NFCAssignmentToAdmin")
  nfcTransactions          NFCCardTransaction[]      @relation("NFCTransactionToDeliverer")
  
  // Relations matching manquantes
  matchingResults          MatchingResult[]          @relation("MatchingResultToDeliverer")
  matchingPreferences      DelivererMatchingPreferences? @relation("DelivererMatchingPreferences")

  @@index([email])
  @@index([role])
  @@index([status])
  @@map("users")
}
// ===== MODÈLES DE VÉRIFICATION =====
// Ces modèles ont été déplacés dans le domaine admin
// Voir admin/documents.prisma, admin/verifications.prisma et admin/audit.prisma 

// ----- DOMAINE: CLIENT -----

// ===== MODÈLES D'ABONNEMENTS CLIENTS ECODELI =====
// Ce fichier contient les modèles pour les formules d'abonnement selon le cahier des charges

/// Plan d'abonnement client EcoDeli avec fonctionnalités spécifiques
model ClientSubscriptionDetail {
  id                    String                  @id @default(cuid())
  userId                String                  @unique
  currentPlan           ClientSubscriptionPlan  @default(FREE)
  
  // Informations de facturation
  monthlyPrice          Decimal                 @db.Decimal(6,2) // Prix mensuel
  currency              String                  @default("EUR")
  stripeSubscriptionId  String?                 @unique
  
  // Dates importantes
  startDate             DateTime                @default(now())
  endDate               DateTime?               // Date de fin (null = actif)
  nextBillingDate       DateTime?               // Prochaine facturation
  cancelAtPeriodEnd     Boolean                 @default(false)
  cancelledAt           DateTime?
  
  // Avantages par plan - FREE
  hasInsurance          Boolean                 @default(false) // Pas d'assurance en FREE
  insuranceAmount       Decimal?                @db.Decimal(8,2) // 115€ STARTER, 3000€ PREMIUM
  
  // Avantages par plan - Réductions
  discountPercentage    Int                     @default(0) // 0% FREE, 5% STARTER, 9% PREMIUM
  hasFirstDeliveryFree  Boolean                 @default(false) // Seulement PREMIUM
  
  // Avantages par plan - Envoi prioritaire
  priorityShippingBonus Int                     @default(0) // +15% tarif en STARTER
  freePriorityPerMonth  Int                     @default(0) // 3 gratuits/mois en PREMIUM
  usedPriorityThisMonth Int                     @default(0) // Compteur mensuel
  
  // Compteurs mensuels (reset chaque mois)
  currentMonthUsage     Json?                   // Usage du mois en cours {deliveries: 0, savings: 0}
  lastResetDate         DateTime?               // Dernière remise à zéro des compteurs
  
  // Historique des changements de plan
  previousPlan          ClientSubscriptionPlan?
  planChangedAt         DateTime?
  planChangeReason      String?                 // Raison du changement
  
  // Paramètres de notification
  billingNotifications  Boolean                 @default(true)
  usageNotifications    Boolean                 @default(true)
  promotionNotifications Boolean                @default(true)
  
  // Métadonnées
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  
  // Relations
  user                  User                    @relation("ClientSubscription", fields: [userId], references: [id], onDelete: Cascade)
  
  // Historique des paiements
  paymentHistory        SubscriptionPayment[]
  
  // Usage mensuel détaillé
  monthlyUsage          MonthlyUsageHistory[]
  
  // Promotions appliquées
  appliedPromotions     SubscriptionPromotion[]

  @@index([currentPlan])
  @@index([nextBillingDate])
  @@index([stripeSubscriptionId])
  @@map("client_subscription_details")
}

/// Historique des paiements d'abonnement
model SubscriptionPayment {
  id              String                    @id @default(cuid())
  subscriptionId  String
  amount          Decimal                   @db.Decimal(8,2)
  currency        String                    @default("EUR")
  status          PaymentStatus             @default(PENDING)
  
  // Informations Stripe
  stripePaymentId String?                   @unique
  stripeInvoiceId String?
  
  // Période couverte
  periodStart     DateTime
  periodEnd       DateTime
  
  // Détails du paiement
  paidAt          DateTime?
  failedAt        DateTime?
  failureReason   String?
  
  // Relations
  subscription    ClientSubscriptionDetail  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt

  @@index([subscriptionId])
  @@index([status])
  @@index([periodStart, periodEnd])
  @@map("subscription_payments")
}

/// Historique d'usage mensuel détaillé
model MonthlyUsageHistory {
  id                    String                    @id @default(cuid())
  subscriptionId        String
  
  // Période
  year                  Int
  month                 Int
  
  // Statistiques d'usage
  totalDeliveries       Int                       @default(0)
  totalAmount           Decimal                   @db.Decimal(10,2) @default(0)
  totalSavings          Decimal                   @db.Decimal(8,2) @default(0)
  
  // Usage des avantages
  priorityDeliveries    Int                       @default(0)
  freePriorityUsed      Int                       @default(0)
  insuranceClaims       Int                       @default(0)
  
  // Détails par type de service
  packageDeliveries     Int                       @default(0)
  personalServices      Int                       @default(0)
  storageUsage          Int                       @default(0) // Heures d'usage box
  
  // Satisfaction
  averageRating         Float?                    // Note moyenne donnée
  customerFeedback      String?                   // Commentaires généraux
  
  // Relations
  subscription          ClientSubscriptionDetail  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime                  @default(now())

  @@unique([subscriptionId, year, month])
  @@index([subscriptionId])
  @@index([year, month])
  @@map("monthly_usage_history")
}

/// Promotions appliquées aux abonnements
model SubscriptionPromotion {
  id              String                    @id @default(cuid())
  subscriptionId  String
  promotionCode   String                    // Code promo utilisé
  promotionType   String                    // TYPE: DISCOUNT, FREE_MONTH, UPGRADE, etc.
  
  // Valeurs de la promotion
  discountAmount  Decimal?                  @db.Decimal(8,2) // Montant de réduction
  discountPercent Int?                      // % de réduction
  freeMonths      Int?                      // Mois gratuits
  
  // Validité
  appliedAt       DateTime                  @default(now())
  validUntil      DateTime?                 // Date limite d'utilisation
  isActive        Boolean                   @default(true)
  
  // Utilisation
  timesUsed       Int                       @default(1)
  maxUsage        Int?                      // Usage maximum autorisé
  
  // Relations
  subscription    ClientSubscriptionDetail  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([promotionCode])
  @@index([validUntil])
  @@map("subscription_promotions")
}

/// Configuration des formules d'abonnement (paramètres globaux)
model SubscriptionPlanConfig {
  id                    String                  @id @default(cuid())
  planType              ClientSubscriptionPlan  @unique
  
  // Prix et facturation
  monthlyPrice          Decimal                 @db.Decimal(6,2)
  yearlyPrice           Decimal?                @db.Decimal(6,2) // Prix annuel (optionnel)
  currency              String                  @default("EUR")
  
  // Avantages inclus
  insuranceAmount       Decimal?                @db.Decimal(8,2)
  discountPercentage    Int                     @default(0)
  priorityShippingBonus Int                     @default(0) // % bonus sur tarif prioritaire
  freePriorityPerMonth  Int                     @default(0)
  hasFirstDeliveryFree  Boolean                 @default(false)
  
  // Limites et restrictions
  maxDeliveriesPerMonth Int?                    // Limite mensuelle (null = illimité)
  maxStorageHours       Int?                    // Heures de stockage incluses
  maxInsuranceClaims    Int?                    // Nombre max de réclamations assurance
  
  // Paramètres commerciaux
  isActive              Boolean                 @default(true)
  sortOrder             Int                     @default(0)
  featuredPlan          Boolean                 @default(false) // Plan mis en avant
  
  // Descriptions marketing
  title                 String                  // Titre commercial
  description           String                  // Description courte
  features              Json                    // Liste des fonctionnalités (array)
  limitations           Json?                   // Limitations spécifiques (array)
  
  // Métadonnées
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  createdBy             String?                 // Admin qui a créé

  @@index([isActive, sortOrder])
  @@map("subscription_plan_configs")
}

// ----- DOMAINE: DELIVERIES -----

// ===== MODÈLES D'ADRESSES =====
// Ce modèle a été déplacé dans le domaine users
// Voir users/profile.prisma 
// ===== MODÈLES D'ANNONCES DE LIVRAISON =====
// Ce fichier contient les modèles pour les annonces de livraison publiées sur la plateforme.

/// Annonce de livraison publiée par un client
model Announcement {
  id                String              @id @default(cuid())
  title             String
  description       String
  status            AnnouncementStatus  @default(DRAFT)
  type              AnnouncementType
  priority          AnnouncementPriority @default(MEDIUM)
  
  // Informations géographiques
  pickupAddress     String
  pickupCity        String
  pickupPostalCode  String
  pickupCountry     String
  pickupLatitude    Float?
  pickupLongitude   Float?
  
  deliveryAddress   String
  deliveryCity      String
  deliveryPostalCode String
  deliveryCountry   String
  deliveryLatitude  Float?
  deliveryLongitude Float?
  
  // Planification
  pickupDate        DateTime?
  deliveryDate      DateTime?
  flexibleDate      Boolean             @default(false)
  
  // Tarification
  suggestedPrice    Float?
  priceType         String?             // "fixed", "negotiable", "hourly"
  currency          String              @default("EUR")
  
  // Spécifique au lâcher de chariot
  merchantId        String?             // Pour les annonces de commerçants
  cartDropSlot      DateTime?           // Créneau horaire pour lâcher de chariot
  isRecurring       Boolean             @default(false) // Annonce récurrente
  recurringDays     String?             // Jours de récurrence (JSON array)
  
  // Spécifique aux livraisons partielles
  intermediatePointAddress String?      // Point intermédiaire pour livraison partielle
  intermediatePointLatitude Float?
  intermediatePointLongitude Float?
  relayDelivererId  String?             // ID du livreur relais pour livraison partielle
  
  // Validation et sécurité
  validationCode    String?             // Code unique généré pour validation
  validationPhoto   String?             // Photo de preuve de livraison
  qrCode            String?             // QR code pour validation rapide
  
  // Assurance et abonnement
  insuranceAmount   Float?              // Montant de l'assurance selon abonnement
  subscriptionTier  String?             // FREE, STARTER, PREMIUM
  priorityDelivery  Boolean             @default(false) // Livraison prioritaire selon abonnement
  
  // Système de matching intelligent
  autoAssign        Boolean             @default(false)  // Assignment automatique activé
  matchingScore     Float?              // Score de matching calculé
  estimatedDistance Float?              // Distance estimée en km
  estimatedDuration Int?                // Durée estimée en minutes
  urgencyLevel      UrgencyLevel        @default(NORMAL)
  
  // Extensions pour matching avancé
  matchingRadius    Float               @default(15.0)   // Rayon de recherche en km
  enableSmartMatching Boolean           @default(true)   // Matching intelligent activé
  routeCompatibility Float?             // Score de compatibilité avec routes existantes
  trafficFactor     Float               @default(1.0)    // Facteur de trafic au moment de la livraison
  weatherSensitive  Boolean             @default(false)  // Sensible aux conditions météo
  
  // Documents et validation
  requiresInsurance Boolean             @default(false)
  requiresSignature Boolean             @default(false)
  confirmationCode  String?             // Code de confirmation généré
  
  // Préférences de livreur
  preferredGender   Gender?             // Préférence de genre du livreur
  minRating         Float?              // Note minimale requise du livreur
  maxApplications   Int                 @default(10)     // Nombre max de candidatures
  
  // Relations
  clientId          String
  delivererId       String?
  
  // Relations avec User
  client            User                @relation("ClientAnnouncements", fields: [clientId], references: [id])
  deliverer         User?               @relation("DelivererAnnouncements", fields: [delivererId], references: [id])
  merchant          User?               @relation("MerchantAnnouncements", fields: [merchantId], references: [id])
  relayDeliverer    User?               @relation("RelayDelivererAnnouncements", fields: [relayDelivererId], references: [id])
  
  // Relations avec d'autres modèles
  applications      DeliveryApplication[]
  favorites         DelivererFavorite[]
  deliveries        Delivery[]
  matchingResults   AnnouncementMatching[]
  delivererNotifications DelivererNotification[] @relation("AnnouncementNotifications")
  routeMatches      PlannedRouteAnnouncement[]  @relation("PlannedRouteAnnouncement")
  routeAnnouncementMatches RouteAnnouncementMatch[] @relation("RouteAnnouncementToAnnouncement")
  
  // Relations matching manquantes
  matchingCriteria  MatchingCriteria[]          @relation("MatchingCriteriaToAnnouncement")
  matchingResultsNew MatchingResult[]           @relation("MatchingResultToAnnouncement")
  routeAnnouncementsOld RouteAnnouncement[]     @relation("RouteAnnouncementToAnnouncement")
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([clientId])
  @@index([delivererId])
  @@index([status])
  @@index([type])
  @@index([pickupCity])
  @@index([deliveryCity])
  @@index([autoAssign])
  @@index([urgencyLevel])
  @@index([matchingScore])
  @@map("announcements")
}

/// Favoris des livreurs pour des annonces spécifiques
model DelivererFavorite {
  id              String       @id @default(cuid())
  delivererId     String
  announcementId  String
  createdAt       DateTime     @default(now())
  
  // Relations avec User et Announcement
  deliverer       User         @relation(fields: [delivererId], references: [id], onDelete: Cascade)
  announcement    Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)

  @@unique([delivererId, announcementId])
  @@index([delivererId])
  @@index([announcementId])
  @@map("deliverer_favorites")
}

/// Résultats du matching automatique annonce-livreur
model AnnouncementMatching {
  id                String      @id @default(cuid())
  announcementId    String
  delivererId       String
  matchingScore     Float       // Score de compatibilité (0-100)
  distanceScore     Float       // Score basé sur la distance
  ratingScore       Float       // Score basé sur les évaluations
  availabilityScore Float       // Score basé sur la disponibilité
  preferenceScore   Float       // Score basé sur les préférences
  
  // Nouveaux critères de scoring
  routeScore        Float       @default(0)  // Score de compatibilité avec routes habituelles
  experienceScore   Float       @default(0)  // Score basé sur l'expérience du livreur
  performanceScore  Float       @default(0)  // Score basé sur les performances passées
  loyaltyScore      Float       @default(0)  // Score de fidélité client-livreur
  
  // Détails du calcul
  distance          Float       // Distance réelle en km
  estimatedTime     Int         // Temps estimé en minutes
  isInRoute         Boolean     @default(false) // Dans une route habituelle
  isAvailable       Boolean     @default(true)  // Livreur disponible
  
  // Facteurs contextuels
  trafficLevel      String      @default("NORMAL") // LOW, NORMAL, HIGH
  weatherCondition  String?     // Conditions météo
  timeOfDay         String?     // Matin, Midi, Soir, Nuit
  dayOfWeek         Int?        // Jour de la semaine (0-6)
  
  // Prédictions ML
  successProbability Float?     // Probabilité de succès prédite (0-100)
  estimatedEarnings Float?      // Gains estimés pour le livreur
  customerSatisfactionPrediction Float? // Satisfaction client prédite
  
  // Statut du matching
  status            MatchingStatus @default(SUGGESTED)
  notifiedAt        DateTime?   // Quand le livreur a été notifié
  respondedAt       DateTime?   // Quand le livreur a répondu
  acceptedAt        DateTime?   // Quand accepté
  rejectedAt        DateTime?   // Quand rejeté
  rejectionReason   String?     // Raison du rejet
  
  // Métadonnées
  calculatedAt      DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  version           Int         @default(1) // Version de l'algorithme utilisé
  
  // Relations
  announcement      Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  deliverer         User         @relation("DelivererMatchings", fields: [delivererId], references: [id], onDelete: Cascade)

  @@unique([announcementId, delivererId])
  @@index([announcementId])
  @@index([delivererId])
  @@index([matchingScore])
  @@index([status])
  @@index([successProbability])
  @@index([calculatedAt])
  @@map("announcement_matchings")
}

/// Historique des notifications envoyées aux livreurs
model DelivererNotification {
  id             String             @id @default(cuid())
  delivererId    String
  announcementId String?            // Null si notification générale
  type           NotificationType
  title          String
  message        String
  
  // Statut de la notification
  status         NotificationStatus @default(PENDING)
  sentAt         DateTime?
  readAt         DateTime?
  respondedAt    DateTime?
  
  // Canaux de notification
  sentByEmail    Boolean           @default(false)
  sentByPush     Boolean           @default(false)
  sentBySms      Boolean           @default(false)
  
  // Métadonnées
  data           Json?             // Données additionnelles
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  
  // Relations
  deliverer      User              @relation("DelivererNotifications", fields: [delivererId], references: [id], onDelete: Cascade)
  announcement   Announcement?     @relation("AnnouncementNotifications", fields: [announcementId], references: [id], onDelete: Cascade)

  @@index([delivererId])
  @@index([announcementId])
  @@index([type])
  @@index([status])
  @@index([sentAt])
  @@map("deliverer_notifications")
}

/// Configuration du système de matching
model MatchingConfiguration {
  id                    String   @id @default(cuid())
  name                  String   @unique
  description           String?
  
  // Poids des différents critères (total = 100)
  distanceWeight        Float    @default(25)   // Importance de la distance
  ratingWeight          Float    @default(20)   // Importance des évaluations
  availabilityWeight    Float    @default(15)   // Importance de la disponibilité
  preferenceWeight      Float    @default(10)   // Importance des préférences
  speedWeight           Float    @default(10)   // Importance de la rapidité
  
  // Nouveaux poids pour critères avancés
  routeWeight           Float    @default(10)   // Importance des routes habituelles
  experienceWeight      Float    @default(5)    // Importance de l'expérience
  performanceWeight     Float    @default(3)    // Importance des performances
  loyaltyWeight         Float    @default(2)    // Importance de la fidélité
  
  // Seuils
  minMatchingScore      Float    @default(60)   // Score minimum pour suggérer
  maxDistance           Float    @default(25)   // Distance maximum en km
  minDelivererRating    Float    @default(3.0)  // Note minimum du livreur
  maxDeliveriesPerHour  Int      @default(3)    // Livraisons max par heure par livreur
  
  // Configuration temporelle
  notificationTimeout   Int      @default(15)   // Timeout en minutes
  maxSuggestions        Int      @default(5)    // Nombre max de suggestions
  reminderInterval      Int      @default(5)    // Intervalle de rappel en minutes
  
  // Facteurs contextuels
  enableWeatherFactor   Boolean  @default(true) // Prendre en compte la météo
  enableTrafficFactor   Boolean  @default(true) // Prendre en compte le trafic
  enableTimeOfDayFactor Boolean  @default(true) // Prendre en compte l'heure
  
  // Machine Learning
  enableMLPredictions   Boolean  @default(false) // Utiliser les prédictions ML
  mlModelVersion        String?  // Version du modèle ML utilisé
  minPredictionConfidence Float  @default(0.7)  // Confiance minimum pour ML
  
  // A/B Testing
  experimentGroup       String?  // Groupe d'expérimentation
  experimentActive      Boolean  @default(false)
  
  // Statut
  isActive              Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([isActive])
  @@index([experimentGroup])
  @@map("matching_configurations")
}

/// Routes annoncées par les livreurs
model DelivererRoute {
  id                String              @id @default(cuid())
  delivererId       String
  
  // Détails du trajet
  departureAddress  String
  departureCity     String
  departurePostalCode String
  departureLatitude Float?
  departureLongitude Float?
  
  arrivalAddress    String
  arrivalCity       String
  arrivalPostalCode String
  arrivalLatitude   Float?
  arrivalLongitude  Float?
  
  // Points de passage optionnels
  waypoints         Json?               // Array de {address, lat, lng}
  
  // Planification
  departureDate     DateTime
  arrivalDate       DateTime
  isRecurring       Boolean             @default(false)
  recurringDays     String?             // JSON array des jours [1,2,3,4,5]
  recurringEndDate  DateTime?           // Date de fin pour les trajets récurrents
  
  // Capacité et préférences
  availableCapacity Float               @default(100) // En pourcentage
  maxPackageSize    String?             // "small", "medium", "large", "extra-large"
  acceptFragile     Boolean             @default(true)
  acceptCooling     Boolean             @default(false)
  vehicleType       VehicleType         @default(CAR)
  
  // Matching et notifications
  enableMatching    Boolean             @default(true)
  notificationRadius Float              @default(10) // Rayon en km pour les notifications
  minPrice          Float?              // Prix minimum accepté
  
  // Statut
  isActive          Boolean             @default(true)
  matchCount        Int                 @default(0) // Nombre de matchs trouvés
  acceptedCount     Int                 @default(0) // Nombre d'annonces acceptées
  
  // Métadonnées
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  // Relations
  deliverer         User                @relation("DelivererRoutes", fields: [delivererId], references: [id])
  matchedAnnouncements RouteAnnouncementMatch[]
  
  @@index([delivererId])
  @@index([departureCity])
  @@index([arrivalCity])
  @@index([departureDate])
  @@index([isActive])
  @@map("deliverer_routes")
}

/// Matching entre routes de livreurs et annonces
model RouteAnnouncementMatch {
  id               String              @id @default(cuid())
  routeId          String
  announcementId   String
  
  // Scores de compatibilité
  matchScore       Float               // Score global (0-100)
  distanceScore    Float               // Proximité géographique
  timeScore        Float               // Compatibilité temporelle
  capacityScore    Float               // Capacité disponible
  
  // Détails du matching
  pickupDetour     Float               // Détour en km pour récupération
  deliveryDetour   Float               // Détour en km pour livraison
  totalDetour      Float               // Détour total
  estimatedProfit  Float               // Profit estimé pour le livreur
  
  // Statut
  status           MatchingStatus      @default(SUGGESTED)
  suggestedAt      DateTime            @default(now())
  notifiedAt       DateTime?
  respondedAt      DateTime?
  
  // Relations
  route            DelivererRoute      @relation(fields: [routeId], references: [id])
  announcement     Announcement        @relation("RouteAnnouncementToAnnouncement", fields: [announcementId], references: [id])
  
  @@unique([routeId, announcementId])
  @@index([routeId])
  @@index([announcementId])
  @@index([matchScore])
  @@index([status])
  @@map("route_announcement_matches")
} 
// ===== MODÈLES D'APPLICATIONS DE LIVRAISON =====
// Ces modèles gèrent les candidatures des livreurs aux annonces
// et leurs préférences. Ces données sont extraites du fichier announcement.prisma
// pour respecter la structure demandée.

// NOTE: Voir announcement.prisma pour les modèles:
// - DeliveryApplication: Candidatures des livreurs
// - DelivererFavorite: Annonces favorites des livreurs 

// ===== MODÈLES DE CANDIDATURE DE LIVRAISON =====
// Ce fichier contient le modèle pour les candidatures des livreurs aux annonces.

/// Candidature d'un livreur pour une annonce
model DeliveryApplication {
  id                    String                      @id @default(cuid())
  delivererId           String
  announcementId        String
  message               String?
  status                ApplicationStatus           @default(PENDING)
  proposedPrice         Float?
  estimatedDuration     Int?                        // Durée estimée en minutes
  availableFrom         DateTime?                   // Disponible à partir de
  availableTo           DateTime?                   // Disponible jusqu'à
  
  // Validation des documents
  documentsVerified     Boolean                     @default(false)
  verificationStatus    DocumentVerificationStatus  @default(PENDING)
  verifiedAt            DateTime?
  verifiedBy            String?                     // ID de l'admin qui a vérifié
  
  // Extensions pour validation avancée
  autoVerificationAttempted Boolean                 @default(false)
  autoVerificationScore Float?                      // Score de vérification automatique (0-100)
  manualReviewRequired  Boolean                     @default(false)
  verificationNotes     String?                     // Notes de l'admin vérificateur
  documentsExpiryCheck  DateTime?                   // Dernière vérification d'expiration
  
  // Évaluation automatique
  autoMatchScore        Float?                      // Score de matching automatique (0-100)
  distanceFromPickup    Float?                      // Distance en km du point de collecte
  distanceFromDelivery  Float?                      // Distance en km du point de livraison
  isInPreferredZone     Boolean                     @default(false)
  
  // Métadonnées
  createdAt             DateTime                    @default(now())
  updatedAt             DateTime                    @updatedAt
  rejectedAt            DateTime?
  rejectionReason       String?
  
  // Relations avec User et Announcement
  deliverer             User                        @relation(fields: [delivererId], references: [id], onDelete: Cascade)
  announcement          Announcement                @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  verifier              User?                       @relation("ApplicationVerifier", fields: [verifiedBy], references: [id])
  
  // Relations avec les documents
  requiredDocuments     ApplicationDocument[]

  @@unique([delivererId, announcementId]) // Un livreur ne peut postuler qu'une fois par annonce
  @@index([delivererId])
  @@index([announcementId])
  @@index([status])
  @@index([verificationStatus])
  @@index([autoMatchScore])
  @@map("delivery_applications")
}

/// Documents requis pour une candidature
model ApplicationDocument {
  id            String                      @id @default(cuid())
  applicationId String
  documentType  RequiredDocumentType        // IDENTITY, DRIVING_LICENSE, INSURANCE, etc.
  documentUrl   String?                     // URL du document uploadé
  status        DocumentVerificationStatus  @default(PENDING)
  uploadedAt    DateTime?
  verifiedAt    DateTime?
  verifiedBy    String?                     // ID de l'admin qui a vérifié
  rejectionReason String?
  expiryDate    DateTime?                   // Date d'expiration du document
  
  // Extensions pour validation avancée
  fileSize      Int?                        // Taille du fichier en bytes
  mimeType      String?                     // Type MIME du document
  ocrText       String?                     // Texte extrait par OCR
  ocrConfidence Float?                      // Niveau de confiance OCR (0-100)
  
  // Validation automatique
  autoValidated Boolean                     @default(false)
  validationScore Float?                    // Score de validation automatique (0-100)
  validationFlags String[]                  // Drapeaux de validation (format JSON)
  
  // Historique des versions
  version       Int                         @default(1)
  previousVersionId String?                 // ID de la version précédente
  replacedAt    DateTime?                   // Date de remplacement
  
  // Métadonnées de sécurité
  checksum      String?                     // Checksum du fichier
  encrypted     Boolean                     @default(false)
  watermarked   Boolean                     @default(false)
  
  createdAt     DateTime                    @default(now())
  updatedAt     DateTime                    @updatedAt
  
  // Relation avec DeliveryApplication
  application   DeliveryApplication         @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  verifier      User?                       @relation("DocumentVerifier", fields: [verifiedBy], references: [id])
  
  // Auto-référence pour l'historique des versions
  previousVersion ApplicationDocument?      @relation("DocumentVersion", fields: [previousVersionId], references: [id])
  nextVersions    ApplicationDocument[]     @relation("DocumentVersion")
  
  // Audit trail
  auditLogs       DocumentValidationAudit[] @relation("DocumentAudit")

  @@unique([applicationId, documentType, version])
  @@index([applicationId])
  @@index([status])
  @@index([documentType])
  @@index([expiryDate])
  @@index([autoValidated])
  @@map("application_documents")
}

/// Préférences du livreur pour les types d'annonces
model DelivererPreferences {
  id                String                 @id @default(cuid())
  delivererId       String                 @unique
  
  // Types d'annonces préférées
  preferredTypes    AnnouncementType[]
  
  // Préférences de distance
  maxDistanceKm     Float                  @default(25)
  minPricePerKm     Float?
  
  // Préférences temporelles
  preferWeekends    Boolean                @default(true)
  preferEvenings    Boolean                @default(true)
  acceptUrgent      Boolean                @default(true)
  
  // Préférences de charge
  maxWeight         Float?                 // kg
  hasVehicle        Boolean                @default(false)
  vehicleType       VehicleType?
  
  // Notifications
  notifyByEmail     Boolean                @default(true)
  notifyByPush      Boolean                @default(true)
  notifyBySms       Boolean                @default(false)
  
  // Métadonnées
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
  
  // Relation avec User
  deliverer         User                   @relation("DelivererPreferences", fields: [delivererId], references: [id], onDelete: Cascade)

  @@index([delivererId])
  @@map("deliverer_preferences")
}

/// Audit des validations de documents
model DocumentValidationAudit {
  id              String                      @id @default(cuid())
  documentId      String
  previousStatus  DocumentVerificationStatus
  newStatus       DocumentVerificationStatus
  actionBy        String                      // ID de l'utilisateur qui a effectué l'action
  actionType      String                      // UPLOAD, VERIFY, REJECT, APPROVE, etc.
  notes           String?                     // Notes de l'action
  
  // Métadonnées de l'action
  ipAddress       String?                     // Adresse IP de l'action
  userAgent       String?                     // User agent
  automated       Boolean                     @default(false) // Action automatisée ou manuelle
  
  // Détails de validation automatique
  validationData  Json?                       // Données de validation (JSON)
  confidence      Float?                      // Niveau de confiance de la validation
  
  createdAt       DateTime                    @default(now())
  
  // Relations
  document        ApplicationDocument         @relation("DocumentAudit", fields: [documentId], references: [id], onDelete: Cascade)
  actor           User                        @relation("ValidationActor", fields: [actionBy], references: [id])

  @@index([documentId])
  @@index([actionBy])
  @@index([actionType])
  @@index([createdAt])
  @@map("document_validation_audits")
} 
// ===== MODÈLES DE LIVRAISONS =====
// Ce fichier contient les modèles pour les livraisons, leur suivi et évaluations.

/// Livraison assignée à un livreur
model Delivery {
  id                 String          @id @default(cuid())
  announcementId     String
  delivererId        String
  clientId           String
  status             DeliveryStatus  @default(PENDING)
  startTime          DateTime?
  completionTime     DateTime?
  actualPickupTime   DateTime?
  actualDeliveryTime DateTime?
  notes              String?
  trackingCode       String          @unique
  price              Float
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  
  // Relations avec Announcement et User
  announcement       Announcement    @relation(fields: [announcementId], references: [id])
  deliverer          User            @relation("DelivererDeliveries", fields: [delivererId], references: [id])
  client             User            @relation("ClientDeliveries", fields: [clientId], references: [id])
  
  // Relations avec d'autres modèles
  logs               DeliveryLog[]
  coordinates        DeliveryCoordinates[]
  proofs             DeliveryProof[]
  ratings            DeliveryRating[]
  payments           Payment[]       @relation("PaymentToDelivery")
  
  // Nouvelles relations pour le cahier des charges
  validationCode     DeliveryValidationCode? @relation("DeliveryValidationCodeToDelivery")
  nfcTransactions    NFCCardTransaction[]    @relation("NFCTransactionToDelivery")

  @@index([announcementId])
  @@index([delivererId])
  @@index([clientId])
  @@index([status])
  @@index([trackingCode])
  @@map("deliveries")
}

/// Journaux d'événements pour une livraison
model DeliveryLog {
  id         String         @id @default(cuid())
  deliveryId String
  status     DeliveryStatusEnum
  message    String
  createdAt  DateTime       @default(now())
  location   String?
  
  // Relation avec Delivery
  delivery   Delivery       @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  @@index([deliveryId])
  @@index([status])
  @@map("delivery_logs")
}

/// Coordonnées GPS enregistrées pendant la livraison
model DeliveryCoordinates {
  id         String    @id @default(cuid())
  deliveryId String
  latitude   Float
  longitude  Float
  timestamp  DateTime  @default(now())
  accuracy   Float?
  speed      Float?
  
  // Relation avec Delivery
  delivery   Delivery  @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  @@index([deliveryId])
  @@map("delivery_coordinates")
}

/// Preuves de livraison (photos, signatures)
model DeliveryProof {
  id           String   @id @default(cuid())
  deliveryId   String
  type         String   // "signature", "photo", "document"
  fileUrl      String
  mimeType     String?
  uploadedAt   DateTime @default(now())
  notes        String?
  
  // Relation avec Delivery
  delivery     Delivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  @@index([deliveryId])
  @@index([type])
  @@map("delivery_proofs")
}

/// Évaluations des livraisons
model DeliveryRating {
  id         String   @id @default(cuid())
  deliveryId String
  ratedById  String   // ID de l'utilisateur qui a donné l'évaluation
  targetId   String   // ID de l'utilisateur qui est évalué
  rating     Int      // 1-5
  comment    String?  // Commentaire en texte libre, pas un type Int
  createdAt  DateTime @default(now())
  
  // Relations avec Delivery et User
  delivery   Delivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)
  ratedBy    User     @relation("RatingGiver", fields: [ratedById], references: [id])
  target     User     @relation("RatingReceiver", fields: [targetId], references: [id])

  @@index([deliveryId])
  @@index([ratedById])
  @@index([targetId])
  @@map("delivery_ratings")
}

/// Planning et disponibilité des livreurs
model DelivererSchedule {
  id           String    @id @default(cuid())
  delivererId  String
  dayOfWeek    Int       // 0=Dimanche, 1=Lundi, etc.
  startTime    String    // Format HH:MM
  endTime      String    // Format HH:MM
  isAvailable  Boolean   @default(true)
  maxDeliveries Int      @default(3)
  
  // Extensions pour planning intelligent
  isRecurring  Boolean   @default(true)   // Planning récurrent ou ponctuel
  breakStart   String?   // Début de pause (HH:MM)
  breakEnd     String?   // Fin de pause (HH:MM)
  timeSlots    Int       @default(4)      // Nombre de créneaux par jour
  preferredZones String[]               // Zones géographiques préférées
  
  // Gestion des exceptions
  exceptions   ScheduleException[]
  
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  
  // Relation avec User
  deliverer    User      @relation("DelivererSchedules", fields: [delivererId], references: [id], onDelete: Cascade)

  @@unique([delivererId, dayOfWeek])
  @@index([delivererId])
  @@index([dayOfWeek])
  @@index([isAvailable])
  @@map("deliverer_schedules")
}

/// Exceptions au planning habituel
model ScheduleException {
  id          String    @id @default(cuid())
  scheduleId  String
  date        DateTime  // Date spécifique de l'exception
  isAvailable Boolean   @default(false)
  startTime   String?   // Nouvelle heure de début si disponible
  endTime     String?   // Nouvelle heure de fin si disponible
  reason      String?   // Raison de l'exception
  createdAt   DateTime  @default(now())
  
  // Relation avec DelivererSchedule
  schedule    DelivererSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  @@unique([scheduleId, date])
  @@index([scheduleId])
  @@index([date])
  @@map("schedule_exceptions")
}

/// Routes habituelles des livreurs - zones de service
model DelivererServiceRoute {
  id               String     @id @default(cuid())
  delivererId      String
  name             String     // Nom donné par le livreur (ex: "Secteur Centre-ville")
  description      String?
  isActive         Boolean    @default(true)
  priority         Int        @default(1) // 1=haute, 2=moyenne, 3=basse
  
  // Extensions pour optimisation intelligente
  estimatedDuration Int?      // Durée moyenne en minutes
  averageEarnings  Float?     // Gains moyens par trajet
  completedDeliveries Int     @default(0)
  successRate      Float?     // Taux de réussite (0-100)
  lastUsed         DateTime?  // Dernière utilisation de cette route
  
  // Paramètres d'optimisation
  maxDeliveries    Int        @default(5)     // Nombre max de livraisons simultanées
  vehicleType      String?    // Type de véhicule requis
  trafficFactor    Float      @default(1.0)   // Facteur de trafic (1.0 = normal)
  weatherSensitive Boolean    @default(false) // Sensible à la météo
  
  // Horaires préférés
  preferredTimeSlots String[] // Créneaux horaires préférés (JSON)
  dayPreferences   Int[]      // Jours de la semaine préférés (0-6)
  
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  
  // Relation avec User et zones
  deliverer        User       @relation("DelivererServiceRoutes", fields: [delivererId], references: [id], onDelete: Cascade)
  zones            DeliveryZone[]
  statistics       RouteStatistics[]
  
  @@index([delivererId])
  @@index([isActive])
  @@index([priority])
  @@index([successRate])
  @@map("deliverer_service_routes")
}

/// Zones géographiques couvertes par les routes
model DeliveryZone {
  id               String         @id @default(cuid())
  routeId          String
  centerLatitude   Float          // Centre de la zone
  centerLongitude  Float
  radiusKm         Float          // Rayon en kilomètres
  cityName         String?        // Nom de la ville/quartier
  postalCodes      String[]       // Codes postaux couverts
  isPreferred      Boolean        @default(false) // Zone préférée du livreur
  
  // Extensions pour analyse de performance
  deliveryCount    Int            @default(0)     // Nombre de livraisons effectuées
  averageTime      Float?         // Temps moyen de livraison (minutes)
  trafficLevel     String         @default("NORMAL") // LOW, NORMAL, HIGH
  parkingDifficulty String        @default("EASY")   // EASY, MEDIUM, HARD
  accessNotes      String?        // Notes d'accès spécifiques
  
  // Restrictions et préférences
  timeRestrictions String[]       // Restrictions horaires
  vehicleRestrictions String[]    // Restrictions de véhicule
  weatherSensitive Boolean        @default(false)
  
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  
  // Relation avec DelivererServiceRoute
  route            DelivererServiceRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  
  @@index([routeId])
  @@index([centerLatitude, centerLongitude])
  @@index([cityName])
  @@index([trafficLevel])
  @@map("delivery_zones")
}

/// Statistiques détaillées des routes
model RouteStatistics {
  id                String         @id @default(cuid())
  routeId           String
  date              DateTime       // Date de la statistique
  
  // Métriques de performance
  totalDeliveries   Int            @default(0)
  completedDeliveries Int          @default(0)
  failedDeliveries  Int            @default(0)
  averageTime       Float?         // Temps moyen en minutes
  totalDistance     Float?         // Distance totale en km
  totalEarnings     Float          @default(0)
  
  // Métriques d'efficacité
  fuelConsumption   Float?         // Consommation estimée
  customerSatisfaction Float?      // Note moyenne des clients
  onTimeRate        Float?         // Taux de ponctualité (0-100)
  
  // Conditions contextuelles
  weatherCondition  String?        // Conditions météo
  trafficCondition  String?        // Conditions de trafic
  dayOfWeek         Int            // Jour de la semaine (0-6)
  
  createdAt         DateTime       @default(now())
  
  // Relation avec DelivererServiceRoute
  route             DelivererServiceRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  
  @@unique([routeId, date])
  @@index([routeId])
  @@index([date])
  @@map("route_statistics")
}

/// Disponibilité temporaire des livreurs
model DelivererAvailability {
  id           String    @id @default(cuid())
  delivererId  String
  startDate    DateTime
  endDate      DateTime
  isAvailable  Boolean   @default(true)
  reason       String?   // Raison de l'indisponibilité
  currentLat   Float?    // Position actuelle
  currentLng   Float?
  lastUpdate   DateTime  @default(now())
  
  // Relation avec User
  deliverer    User      @relation("DelivererAvailabilities", fields: [delivererId], references: [id], onDelete: Cascade)

  @@index([delivererId])
  @@index([startDate, endDate])
  @@index([isAvailable])
  @@map("deliverer_availabilities")
}

/// Statistiques de performance des livreurs
model DelivererStats {
  id                    String   @id @default(cuid())
  delivererId           String   @unique
  totalDeliveries       Int      @default(0)
  completedDeliveries   Int      @default(0)
  cancelledDeliveries   Int      @default(0)
  averageRating         Float?
  totalRatings          Int      @default(0)
  totalDistance         Float    @default(0) // en km
  totalEarnings         Float    @default(0)
  bestCompletionTime    Int?     // en minutes
  averageCompletionTime Float?   // en minutes
  lastDeliveryDate      DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relation avec User
  deliverer             User     @relation("DelivererStats", fields: [delivererId], references: [id], onDelete: Cascade)

  @@index([delivererId])
  @@index([averageRating])
  @@map("deliverer_stats")
} 
// ===== SYSTÈME DE MATCHING AUTOMATIQUE =====

/// Algorithme de matching utilisé
enum MatchingAlgorithm {
  DISTANCE_BASED    // Basé sur la distance
  TIME_OPTIMIZED    // Optimisé pour le temps
  COST_EFFICIENT    // Efficace en coût
  HYBRID            // Hybride (distance + temps + coût)
  AI_ENHANCED       // Amélioré par IA
  MANUAL            // Attribution manuelle
}

/// Type de critère de matching
enum MatchingCriteriaType {
  DISTANCE          // Distance maximale
  TIME_WINDOW       // Fenêtre de temps
  VEHICLE_TYPE      // Type de véhicule
  PACKAGE_TYPE      // Type de colis
  WEIGHT_LIMIT      // Limite de poids
  PRICE_RANGE       // Fourchette de prix
  RATING_MINIMUM    // Note minimale
  LANGUAGE          // Langue
  GENDER_PREFERENCE // Préférence de genre
  CUSTOM            // Critère personnalisé
}

/// Priorité de matching
enum MatchingPriority {
  LOW       // Faible - matching automatique
  NORMAL    // Normal - matching standard
  HIGH      // Élevé - matching prioritaire
  URGENT    // Urgent - matching immédiat
  CRITICAL  // Critique - matching manuel requis
}

/// Statut de résultat de matching
enum MatchingResultStatus {
  PENDING       // En attente
  SUGGESTED     // Suggéré
  ACCEPTED      // Accepté
  REJECTED      // Rejeté
  EXPIRED       // Expiré
  CANCELLED     // Annulé
  AUTO_ASSIGNED // Assigné automatiquement
}

/// Modèle de critères de matching
model MatchingCriteria {
  id                String              @id @default(cuid())
  announcementId    String              @unique
  algorithm         MatchingAlgorithm   @default(HYBRID)
  priority          MatchingPriority    @default(NORMAL)
  
  // Critères géographiques
  maxDistance       Float?              // Distance maximale en km
  preferredRadius   Float?              // Rayon préféré en km
  allowPartialRoute Boolean             @default(true) // Autoriser les trajets partiels
  
  // Critères temporels
  timeWindowStart   DateTime?           // Début de la fenêtre temporelle
  timeWindowEnd     DateTime?           // Fin de la fenêtre temporelle
  maxDelay          Int?                // Retard maximum accepté (en minutes)
  
  // Critères de véhicule
  requiredVehicleTypes VehicleType[]    // Types de véhicules requis
  minVehicleCapacity   Float?           // Capacité minimale du véhicule
  
  // Critères de livreur
  minDelivererRating   Float?           // Note minimale du livreur
  preferredLanguages   String[]         // Langues préférées
  genderPreference     Gender?          // Préférence de genre
  
  // Critères de prix
  maxPrice          Decimal?            @db.Decimal(10, 2) // Prix maximum
  minPrice          Decimal?            @db.Decimal(10, 2) // Prix minimum
  allowNegotiation  Boolean             @default(true)     // Autoriser la négociation
  
  // Critères de colis
  packageTypes      PackageType[]       // Types de colis acceptés
  maxWeight         Float?              // Poids maximum
  requiresHandling  Boolean             @default(false)    // Nécessite une manipulation spéciale
  
  // Configuration avancée
  autoAssignAfter   Int?                // Auto-assignation après X minutes
  maxSuggestions    Int                 @default(5)        // Nombre maximum de suggestions
  scoreThreshold    Float               @default(0.6)      // Seuil de score minimum
  
  // Relations
  announcement      Announcement        @relation("MatchingCriteriaToAnnouncement", fields: [announcementId], references: [id], onDelete: Cascade)
  results           MatchingResult[]
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@map("matching_criteria")
}

/// Modèle de résultat de matching
model MatchingResult {
  id               String               @id @default(cuid())
  criteriaId       String
  delivererId      String
  announcementId   String
  status           MatchingResultStatus @default(PENDING)
  
  // Scores de matching
  overallScore     Float                // Score global (0-1)
  distanceScore    Float                // Score de distance (0-1)
  timeScore        Float                // Score de temps (0-1)
  priceScore       Float                // Score de prix (0-1)
  ratingScore      Float                // Score de notation (0-1)
  
  // Détails du matching
  calculatedDistance Float              // Distance calculée en km
  estimatedDuration  Int                // Durée estimée en minutes
  suggestedPrice     Decimal            @db.Decimal(10, 2) // Prix suggéré
  
  // Métadonnées de matching
  algorithm        MatchingAlgorithm    // Algorithme utilisé
  processingTime   Int                  // Temps de traitement en ms
  confidenceLevel  Float               // Niveau de confiance (0-1)
  
  // Timestamps
  suggestedAt      DateTime            @default(now())
  respondedAt      DateTime?           // Date de réponse du livreur
  expiresAt        DateTime            // Date d'expiration de la suggestion
  
  // Raison du rejet si applicable
  rejectionReason  String?
  
  // Relations
  criteria         MatchingCriteria    @relation(fields: [criteriaId], references: [id], onDelete: Cascade)
  deliverer        User                @relation("MatchingResultToDeliverer", fields: [delivererId], references: [id], onDelete: Cascade)
  announcement     Announcement        @relation("MatchingResultToAnnouncement", fields: [announcementId], references: [id], onDelete: Cascade)
  
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  @@unique([criteriaId, delivererId])
  @@map("matching_results")
}

/// Modèle de préférences de matching pour les livreurs
model DelivererMatchingPreferences {
  id                    String        @id @default(cuid())
  delivererId           String        @unique
  
  // Préférences géographiques
  preferredRadius       Float         @default(10.0) // Rayon préféré en km
  maxRadius             Float         @default(25.0) // Rayon maximum en km
  homeLatitude          Float?        // Latitude du domicile
  homeLongitude         Float?        // Longitude du domicile
  
  // Préférences temporelles
  availableFrom         String?       // Heure de début (format HH:MM)
  availableTo           String?       // Heure de fin (format HH:MM)
  availableDays         Int[]         // Jours disponibles (0=dimanche, 6=samedi)
  maxWorkingHours       Int           @default(8)    // Heures de travail max par jour
  
  // Préférences de colis
  acceptedPackageTypes  PackageType[] // Types de colis acceptés
  maxPackageWeight      Float         @default(20.0) // Poids maximum en kg
  acceptFragile         Boolean       @default(true)  // Accepter les colis fragiles
  acceptRefrigerated    Boolean       @default(false) // Accepter les colis réfrigérés
  
  // Préférences financières
  minPrice              Decimal       @db.Decimal(10, 2) @default(5.00) // Prix minimum
  maxPrice              Decimal?      @db.Decimal(10, 2) // Prix maximum
  acceptNegotiation     Boolean       @default(true)     // Accepter la négociation
  
  // Préférences de notification
  instantNotification   Boolean       @default(true)  // Notification instantanée
  maxSuggestions        Int           @default(10)    // Nombre max de suggestions par jour
  autoDeclineAfter      Int           @default(60)    // Auto-refus après X minutes
  
  // Statistiques de performance
  averageResponseTime   Int           @default(0)     // Temps de réponse moyen en minutes
  acceptanceRate        Float         @default(0.0)   // Taux d'acceptation (0-1)
  completionRate        Float         @default(0.0)   // Taux de completion (0-1)
  
  // Relations
  deliverer             User          @relation("DelivererMatchingPreferences", fields: [delivererId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  @@map("deliverer_matching_preferences")
}

/// Modèle de route planifiée pour les livreurs


/// Modèle de liaison entre route et annonce
model RouteAnnouncement {
  id             String       @id @default(cuid())
  routeId        String
  announcementId String
  
  // Détails du match
  matchScore     Float        // Score de compatibilité (0-1)
  detourDistance Float        // Distance de détour en km
  detourTime     Int          // Temps de détour en minutes
  priceOffered   Decimal      @db.Decimal(10, 2) // Prix proposé
  
  // Statut
  status         MatchingStatus @default(SUGGESTED)
  matchedAt      DateTime       @default(now())
  respondedAt    DateTime?
  
  // Relations
  route          DelivererPlannedRoute   @relation(fields: [routeId], references: [id], onDelete: Cascade)
  announcement   Announcement   @relation("RouteAnnouncementToAnnouncement", fields: [announcementId], references: [id], onDelete: Cascade)
  
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@unique([routeId, announcementId])
  @@map("route_announcements")
}
// ===== NFC CARD MANAGEMENT =====

/// Statut d'une carte NFC
enum NFCCardStatus {
  ACTIVE      // Active
  INACTIVE    // Inactive
  BLOCKED     // Bloquée
  LOST        // Perdue
  STOLEN      // Volée
  DAMAGED     // Endommagée
  EXPIRED     // Expirée
}

/// Type de transaction NFC
enum NFCTransactionType {
  DELIVERY_START    // Début de livraison
  DELIVERY_END      // Fin de livraison
  PACKAGE_PICKUP    // Récupération de colis
  PACKAGE_DELIVERY  // Livraison de colis
  VALIDATION        // Validation
  ACCESS_GRANT      // Autorisation d'accès
  SYSTEM_CHECK      // Vérification système
}

/// Statut d'assignation de carte NFC
enum NFCAssignmentStatus {
  ASSIGNED   // Assignée
  UNASSIGNED // Non assignée
  PENDING    // En attente
  REVOKED    // Révoquée
}

/// Modèle de carte NFC pour les livreurs
model NFCCard {
  id           String        @id @default(cuid())
  cardNumber   String        @unique // Numéro unique de la carte
  serialNumber String?       @unique // Numéro de série physique
  status       NFCCardStatus @default(INACTIVE)
  issuedAt     DateTime      @default(now())
  expiresAt    DateTime?     // Date d'expiration
  lastUsedAt   DateTime?     // Dernière utilisation

  // Relations
  delivererId String?
  deliverer   User?   @relation("NFCCardToDeliverer", fields: [delivererId], references: [id], onDelete: SetNull)

  // Historique des assignations
  assignments NFCCardAssignment[]
  
  // Transactions effectuées avec cette carte
  transactions NFCCardTransaction[]

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("nfc_cards")
}

/// Modèle d'assignation de carte NFC
model NFCCardAssignment {
  id          String              @id @default(cuid())
  cardId      String
  delivererId String
  status      NFCAssignmentStatus @default(PENDING)
  assignedAt  DateTime            @default(now())
  unassignedAt DateTime?
  reason      String?             // Raison de l'assignation/révocation
  assignedBy  String?             // ID de l'admin qui a fait l'assignation

  // Relations
  card      NFCCard @relation(fields: [cardId], references: [id], onDelete: Cascade)
  deliverer User    @relation("NFCAssignmentToDeliverer", fields: [delivererId], references: [id], onDelete: Cascade)
  admin     User?   @relation("NFCAssignmentToAdmin", fields: [assignedBy], references: [id], onDelete: SetNull)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("nfc_card_assignments")
}

/// Modèle de transaction NFC
model NFCCardTransaction {
  id            String             @id @default(cuid())
  cardId        String
  delivererId   String
  transactionType NFCTransactionType
  amount        Decimal?           @db.Decimal(10, 2) // Montant si applicable
  description   String?
  location      String?            // Localisation de la transaction
  gpsLatitude   Float?
  gpsLongitude  Float?
  deviceInfo    String?            // Informations sur le dispositif de lecture
  isSuccessful  Boolean            @default(true)
  errorMessage  String?            // Message d'erreur si échec

  // Relations
  card        NFCCard @relation(fields: [cardId], references: [id], onDelete: Cascade)
  deliverer   User    @relation("NFCTransactionToDeliverer", fields: [delivererId], references: [id], onDelete: Cascade)
  
  // Relation optionnelle avec une livraison
  deliveryId  String?
  delivery    Delivery? @relation("NFCTransactionToDelivery", fields: [deliveryId], references: [id], onDelete: SetNull)

  // Métadonnées
  transactionAt DateTime @default(now())
  createdAt     DateTime @default(now())

  @@map("nfc_card_transactions")
}

/// Modèle de validation de code de livraison
model DeliveryValidationCode {
  id          String  @id @default(cuid())
  deliveryId  String  @unique
  code        String  @unique // Code de validation (6-8 chiffres)
  isUsed      Boolean @default(false)
  usedAt      DateTime?
  expiresAt   DateTime // Date d'expiration du code
  
  // Relations
  delivery    Delivery @relation("DeliveryValidationCodeToDelivery", fields: [deliveryId], references: [id], onDelete: Cascade)
  
  // Métadonnées de validation
  generatedBy String? // ID de l'utilisateur qui a généré le code
  validatedBy String? // ID de l'utilisateur qui a utilisé le code
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("delivery_validation_codes")
}
// ===== MODÈLES DE ROUTES PLANIFIÉES =====
// Ce fichier contient les modèles pour la gestion des trajets planifiés des livreurs selon le cahier des charges

/// Route planifiée à l'avance par un livreur selon le cahier des charges
model DelivererPlannedRoute {
  id                String              @id @default(cuid())
  delivererId       String
  title             String              // Titre de la route (ex: "Paris-Marseille hebdomadaire")
  description       String?             // Description détaillée
  status            PlannedRouteStatus  @default(DRAFT)
  
  // Points de départ et d'arrivée
  departureAddress  String              // Adresse de départ
  departureLat      Float               // Latitude départ
  departureLng      Float               // Longitude départ
  arrivalAddress    String              // Adresse d'arrivée
  arrivalLat        Float               // Latitude arrivée
  arrivalLng        Float               // Longitude arrivée
  
  // Planning temporel
  departureTime     DateTime            // Heure de départ prévue
  arrivalTime       DateTime            // Heure d'arrivée prévue
  isRecurring       Boolean             @default(false) // Route récurrente
  recurringPattern  String?             // Pattern de récurrence (JSON: jours, fréquence)
  
  // Capacités et restrictions
  maxWeight         Float?              // Poids maximum en kg
  maxVolume         Float?              // Volume maximum en m³
  maxPackages       Int?                // Nombre maximum de colis
  vehicleRequired   VehicleType?        // Type de véhicule requis
  
  // Paramètres financiers
  pricePerKm        Float?              // Prix par kilomètre
  fixedPrice        Float?              // Prix fixe pour la route
  minimumPrice      Float?              // Prix minimum
  
  // Points d'arrêt intermédiaires
  waypoints         Json?               // Points de passage (array d'objets {address, lat, lng, timeWindow})
  
  // Disponibilité
  availableSeats    Int?                // Places disponibles (transport personnes)
  isPublic          Boolean             @default(true) // Visible publiquement
  
  // Métadonnées de performance
  estimatedDistance Float?              // Distance estimée en km
  estimatedDuration Int?                // Durée estimée en minutes
  actualDistance    Float?              // Distance réelle parcourue
  actualDuration    Int?                // Durée réelle en minutes
  
  // Notifications et matching
  notifyOnMatch     Boolean             @default(true) // Notifier lors d'un match
  autoAcceptMatch   Boolean             @default(false) // Acceptation automatique des matches
  
  // Métadonnées
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  publishedAt       DateTime?           // Date de publication
  completedAt       DateTime?           // Date de complétion
  
  // Relations
  deliverer         User                @relation("DelivererPlannedRouteToDeliverer", fields: [delivererId], references: [id], onDelete: Cascade)
  
  // Annonces matchées avec cette route
  matchedAnnouncements PlannedRouteAnnouncement[]
  routeAnnouncements   RouteAnnouncement[]
  
  // Historique des performances
  performanceHistory DelivererRoutePerformance[]

  @@index([delivererId])
  @@index([status])
  @@index([departureTime])
  @@index([isRecurring])
  @@index([isPublic])
  @@map("deliverer_planned_routes")
}

/// Association entre une route planifiée et une annonce matchée
model PlannedRouteAnnouncement {
  id              String              @id @default(cuid())
  routeId         String
  announcementId  String
  matchScore      Float?              // Score de matching (0-100)
  status          MatchingStatus      @default(SUGGESTED)
  
  // Détails du match
  pickupOrder     Int?                // Ordre de récupération
  deliveryOrder   Int?                // Ordre de livraison
  detourDistance  Float?              // Distance de détour en km
  detourTime      Int?                // Temps de détour en minutes
  
  // Validation
  delivererAccepted Boolean           @default(false)
  clientAccepted   Boolean            @default(false)
  matchedAt        DateTime           @default(now())
  acceptedAt       DateTime?
  rejectedAt       DateTime?
  
  // Relations
  route           DelivererPlannedRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  announcement    Announcement        @relation("PlannedRouteAnnouncement", fields: [announcementId], references: [id], onDelete: Cascade)
  
  @@unique([routeId, announcementId])
  @@index([routeId])
  @@index([announcementId])
  @@index([status])
  @@map("planned_route_announcements")
}

/// Historique des performances d'une route
model DelivererRoutePerformance {
  id                String           @id @default(cuid())
  routeId           String
  executionDate     DateTime         // Date d'exécution de la route
  
  // Métriques de performance
  actualDistance    Float            // Distance réelle parcourue
  actualDuration    Int              // Durée réelle en minutes
  fuelCost          Float?           // Coût du carburant
  tollCost          Float?           // Coût des péages
  totalEarnings     Float            // Gains totaux
  
  // Livraisons effectuées
  packagesDelivered Int              @default(0)
  onTimeDeliveries  Int              @default(0)
  lateDeliveries    Int              @default(0)
  
  // Satisfaction
  averageRating     Float?           // Note moyenne des clients
  customerFeedback  String?          // Commentaires clients
  
  // Problèmes rencontrés
  issues            Json?            // Liste des problèmes (JSON array)
  delays            Json?            // Détails des retards (JSON array)
  
  // Métadonnées
  createdAt         DateTime         @default(now())
  notes             String?          // Notes du livreur
  
  // Relations
  route             DelivererPlannedRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)

  @@index([routeId])
  @@index([executionDate])
  @@map("deliverer_route_performances")
}

/// Optimisation des trajets
model RouteOptimization {
  id                String           @id @default(cuid())
  delivererId       String
  requestedAt       DateTime         @default(now())
  
  // Paramètres d'entrée
  startingPoint     Json             // Point de départ {address, lat, lng}
  destinations      Json             // Destinations à visiter (array)
  constraints       Json             // Contraintes (horaires, capacités, etc.)
  
  // Résultats d'optimisation
  optimizedRoute    Json?            // Route optimisée (array d'étapes)
  totalDistance     Float?           // Distance totale
  totalDuration     Int?             // Durée totale
  estimatedEarnings Float?           // Gains estimés
  
  // Statut
  status            String           @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  completedAt       DateTime?
  errorMessage      String?
  
  // Relations
  deliverer         User             @relation("RouteOptimization", fields: [delivererId], references: [id], onDelete: Cascade)

  @@index([delivererId])
  @@index([status])
  @@map("route_optimizations")
}

// ----- DOMAINE: SERVICES -----

// ===== MODÈLES DE DISPONIBILITÉ DES PRESTATAIRES =====
// Ce fichier contient le modèle pour gérer les disponibilités des prestataires de services.

/// Disponibilité d'un prestataire de service par jour et créneau horaire
model ProviderAvailability {
  id         String   @id @default(cuid())
  providerId String
  dayOfWeek  Int      // 0 = Dimanche, 1 = Lundi, ..., 6 = Samedi
  startTime  DateTime
  endTime    DateTime
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  // Relation avec User
  provider   User     @relation(fields: [providerId], references: [id])

  @@index([providerId, dayOfWeek])
  @@index([isActive])
}

/// Exceptions de disponibilité (congés, fermetures exceptionnelles)
model ProviderException {
  id           String      @id @default(cuid())
  providerId   String
  date         DateTime    // Date de l'exception
  type         ExceptionType
  startTime    DateTime?   // Heure de début (si partielle)
  endTime      DateTime?   // Heure de fin (si partielle)
  reason       String?     // Raison de l'exception
  isRecurring  Boolean     @default(false)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  
  // Relation avec User
  provider     User        @relation(fields: [providerId], references: [id])

  @@index([providerId, date])
}

/// Créneaux spéciaux (disponibilités additionnelles)
model ProviderSpecialSlot {
  id         String   @id @default(cuid())
  providerId String
  date       DateTime
  startTime  DateTime
  endTime    DateTime
  isBooked   Boolean  @default(false)
  notes      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  // Relation avec User
  provider   User     @relation(fields: [providerId], references: [id])

  @@index([providerId, date])
  @@index([isBooked])
} 
// ===== MODÈLES DE RÉSERVATION DE SERVICES =====
// Ce fichier contient les modèles pour les réservations de services et évaluations.

/// Réservation d'un service
model ServiceBooking {
  id              String         @id @default(cuid())
  clientId        String
  providerId      String
  serviceId       String
  startTime       DateTime
  endTime         DateTime
  status          BookingStatus  @default(PENDING)
  totalPrice      Decimal
  paymentId       String?
  notes           String?
  clientNotes     String?        // Notes du client
  providerNotes   String?        // Notes privées du prestataire
  confirmationCode String?       // Code de confirmation
  location        String?        // Lieu du service si différent
  participantCount Int          @default(1)
  reminderSent    Boolean       @default(false)
  cancelledAt     DateTime?
  cancelledBy     String?       // ID de qui a annulé
  cancellationReason String?
  rescheduledFrom String?       // ID de la réservation originale si reprogrammée
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations avec User, Service et Payment
  client          User          @relation("ClientBookings", fields: [clientId], references: [id])
  provider        User          @relation("ProviderBookings", fields: [providerId], references: [id])
  service         Service       @relation(fields: [serviceId], references: [id])
  payment         Payment?      @relation(fields: [paymentId], references: [id])
  review          ServiceReview?
  rescheduledTo   ServiceBooking[] @relation("BookingReschedule")
  originalBooking ServiceBooking?  @relation("BookingReschedule", fields: [rescheduledFrom], references: [id])
  appointments    ClientAppointment[] // Rendez-vous liés à cette réservation

  @@index([clientId])
  @@index([providerId])
  @@index([serviceId])
  @@index([paymentId])
  @@index([status])
  @@index([startTime])
}



/// Évaluation d'un service après réservation
model ServiceReview {
  id          String         @id @default(cuid())
  bookingId   String         @unique
  rating      Int            // Note de 1 à 5
  comment     String?
  pros        String[]       // Points positifs
  cons        String[]       // Points négatifs
  wouldRecommend Boolean?    // Recommanderait-il ce service
  punctuality Int?          // Note pour la ponctualité (1-5)
  quality     Int?          // Note pour la qualité (1-5)
  communication Int?        // Note pour la communication (1-5)
  valueForMoney Int?        // Note pour le rapport qualité-prix (1-5)
  isVerified  Boolean       @default(false) // Évaluation vérifiée
  helpfulVotes Int          @default(0)     // Votes "utile"
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  // Relation avec la réservation
  booking     ServiceBooking @relation(fields: [bookingId], references: [id])

  @@index([rating])
  @@index([createdAt])
  @@index([isVerified])
} 
// ===== MODÈLES SERVICES À LA PERSONNE =====
// Ce fichier contient les modèles pour les services spécifiques selon le cahier des charges

/// Service à la personne spécialisé
model PersonalService {
  id                String               @id @default(cuid())
  providerId        String               // Prestataire qui offre le service
  serviceType       PersonalServiceType  // Type de service selon cahier des charges
  
  // Informations de base
  title             String               // Titre du service
  description       String               @db.Text // Description détaillée
  shortDescription  String?              // Description courte pour listing
  
  // Tarification
  basePrice         Decimal              @db.Decimal(8,2) // Prix de base
  pricePerHour      Decimal?             @db.Decimal(6,2) // Prix horaire si applicable
  pricePerKm        Decimal?             @db.Decimal(4,2) // Prix au kilomètre si applicable
  minimumPrice      Decimal?             @db.Decimal(6,2) // Prix minimum
  
  // Disponibilité géographique
  serviceRadius     Float                @default(25) // Rayon d'intervention en km
  baseLocation      String               // Adresse de base du prestataire
  baseLat           Float                // Latitude base
  baseLng           Float                // Longitude base
  
  // Spécificités par type de service
  
  // PERSON_TRANSPORT - Transport de personnes
  maxPassengers     Int?                 // Nombre max de passagers
  hasWheelchairAccess Boolean?           // Accessible PMR
  vehicleType       VehicleType?         // Type de véhicule
  hasChildSeat      Boolean?             // Siège enfant disponible
  
  // AIRPORT_TRANSFER - Transfert aéroport
  airportCoverage   String[]             // Aéroports desservis (codes IATA)
  trackFlights      Boolean?             // Suivi des vols
  waitingIncluded   Int?                 // Minutes d'attente incluses
  luggageCapacity   String?              // Capacité bagages
  
  // GROCERY_SHOPPING - Courses
  maxShoppingValue  Decimal?             @db.Decimal(8,2) // Valeur max des courses
  hasShoppingCard   Boolean?             // Possède cartes de fidélité
  preferredStores   String[]             // Magasins préférés
  specialtyProducts Boolean?             // Produits spécialisés (bio, halal, etc.)
  
  // INTERNATIONAL_PURCHASE - Achats à l'étranger
  countriesCovered  String[]             // Pays couverts (codes ISO)
  maxPurchaseValue  Decimal?             @db.Decimal(10,2) // Valeur max d'achat
  customsHandling   Boolean?             // Gestion douanes
  shippingIncluded  Boolean?             // Expédition incluse
  
  // PET_SITTING - Garde d'animaux
  petTypesAccepted  String[]             // Types d'animaux acceptés
  maxPetSize        String?              // Taille max (small, medium, large)
  hasVeterinaryExp  Boolean?             // Expérience vétérinaire
  homeOrTravel      String?              // À domicile ou déplacement
  
  // HOME_SERVICES - Services à domicile
  serviceCategories String[]             // Catégories (ménage, jardinage, etc.)
  toolsProvided     Boolean?             // Outils fournis
  materialsIncluded Boolean?             // Matériaux inclus
  maxJobDuration    Int?                 // Durée max en heures
  
  // Qualifications et certifications
  certifications    Json?                // Certifications du prestataire
  insurance         Json?                // Assurances souscrites
  backgroundCheck   Boolean              @default(false) // Vérification casier
  
  // Paramètres de service
  advanceBooking    Int                  @default(24) // Préavis requis en heures
  cancellationPolicy String?            // Politique d'annulation
  isEmergencyService Boolean             @default(false) // Service d'urgence
  
  // Disponibilité
  isActive          Boolean              @default(true)
  isApproved        Boolean              @default(false) // Approuvé par admin
  approvedAt        DateTime?
  approvedBy        String?              // Admin qui a approuvé
  
  // Évaluations
  averageRating     Float?               // Note moyenne sur 5
  totalReviews      Int                  @default(0)
  totalBookings     Int                  @default(0)
  
  // Métadonnées
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  
  // Relations
  provider          User                 @relation("PersonalServiceProvider", fields: [providerId], references: [id], onDelete: Cascade)
  approver          User?                @relation("PersonalServiceApprover", fields: [approvedBy], references: [id])
  
  // Réservations de ce service
  bookings          PersonalServiceBooking[]
  
  // Évaluations reçues
  reviews           PersonalServiceReview[]
  
  // Photos du service
  photos            PersonalServicePhoto[]

  @@index([providerId])
  @@index([serviceType])
  @@index([isActive, isApproved])
  @@index([averageRating])
  @@index([baseLat, baseLng]) // Pour recherche géographique
  @@map("personal_services")
}

/// Réservation d'un service à la personne
model PersonalServiceBooking {
  id                String               @id @default(cuid())
  serviceId         String
  clientId          String
  
  // Détails de la réservation
  scheduledAt       DateTime             // Date/heure programmée
  duration          Int?                 // Durée estimée en minutes
  status            BookingStatus        @default(PENDING)
  
  // Lieu du service
  serviceAddress    String               // Adresse où effectuer le service
  serviceLat        Float                // Latitude
  serviceLng        Float                // Longitude
  accessInstructions String?             // Instructions d'accès
  
  // Détails spécifiques selon le type
  serviceDetails    Json                 // Détails spécifiques (JSON)
  specialRequests   String?              // Demandes spéciales du client
  
  // Tarification
  quotedPrice       Decimal              @db.Decimal(8,2) // Prix devisé
  finalPrice        Decimal?             @db.Decimal(8,2) // Prix final
  extraCharges      Json?                // Frais supplémentaires détaillés
  
  // Suivi de l'intervention
  providerArrivedAt DateTime?            // Arrivée du prestataire
  serviceStartedAt  DateTime?            // Début du service
  serviceCompletedAt DateTime?           // Fin du service
  
  // Photos et preuves
  beforePhotos      String[]             // Photos avant intervention
  afterPhotos       String[]             // Photos après intervention
  completionProof   String?              // Preuve de réalisation
  
  // Communication
  clientNotes       String?              // Notes du client
  providerNotes     String?              // Notes du prestataire
  
  // Paiement
  isPaid            Boolean              @default(false)
  paidAt            DateTime?
  paymentMethod     String?              // Méthode de paiement
  
  // Annulation/Report
  cancelledAt       DateTime?
  cancellationReason CancellationReason?
  rescheduledFrom   DateTime?            // Programmation précédente
  rescheduledTo     DateTime?            // Nouvelle programmation
  
  // Métadonnées
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  
  // Relations
  service           PersonalService      @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  client            User                 @relation("PersonalServiceClient", fields: [clientId], references: [id], onDelete: Cascade)
  
  // Évaluation de cette réservation
  review            PersonalServiceReview?

  @@index([serviceId])
  @@index([clientId])
  @@index([status])
  @@index([scheduledAt])
  @@map("personal_service_bookings")
}

/// Évaluations des services à la personne
model PersonalServiceReview {
  id              String                 @id @default(cuid())
  serviceId       String
  bookingId       String                 @unique // Une évaluation par réservation
  clientId        String
  providerId      String
  
  // Évaluation
  rating          Int                    // Note sur 5
  comment         String?                @db.Text // Commentaire détaillé
  
  // Critères d'évaluation spécifiques
  punctuality     Int?                   // Ponctualité sur 5
  quality         Int?                   // Qualité sur 5
  communication   Int?                   // Communication sur 5
  value           Int?                   // Rapport qualité/prix sur 5
  
  // Recommandation
  wouldRecommend  Boolean?               // Recommanderait-il ?
  wouldBookAgain  Boolean?               // Re-réserverait-il ?
  
  // Réponse du prestataire
  providerResponse String?               @db.Text // Réponse du prestataire
  providerResponseAt DateTime?           // Date de réponse
  
  // Modération
  isModerated     Boolean                @default(false)
  isPublic        Boolean                @default(true)
  moderatedBy     String?                // Admin modérateur
  moderatedAt     DateTime?
  moderationNotes String?                // Notes de modération
  
  // Métadonnées
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  
  // Relations
  service         PersonalService        @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  booking         PersonalServiceBooking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  client          User                   @relation("PersonalServiceReviewer", fields: [clientId], references: [id], onDelete: Cascade)
  provider        User                   @relation("PersonalServiceReviewed", fields: [providerId], references: [id], onDelete: Cascade)
  moderator       User?                  @relation("PersonalServiceModerator", fields: [moderatedBy], references: [id])

  @@index([serviceId])
  @@index([clientId])
  @@index([providerId])
  @@index([rating])
  @@index([isPublic])
  @@map("personal_service_reviews")
}

/// Photos des services à la personne
model PersonalServicePhoto {
  id              String          @id @default(cuid())
  serviceId       String
  url             String          // URL de la photo
  caption         String?         // Légende
  sortOrder       Int             @default(0) // Ordre d'affichage
  isMainPhoto     Boolean         @default(false) // Photo principale
  
  // Métadonnées de l'image
  fileSize        Int?            // Taille en bytes
  mimeType        String?         // Type MIME
  width           Int?            // Largeur en pixels
  height          Int?            // Hauteur en pixels
  
  createdAt       DateTime        @default(now())
  
  // Relations
  service         PersonalService @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@index([serviceId, sortOrder])
  @@index([isMainPhoto])
  @@map("personal_service_photos")
}
// ===== MODÈLES HABILITATIONS ET ÉVALUATIONS PRESTATAIRES =====
// Ce fichier contient les modèles pour la validation et le suivi des prestataires selon le cahier des charges

/// Habilitation spécifique d'un prestataire
model ProviderHabilitation {
  id                String              @id @default(cuid())
  providerId        String
  habilitationType  String              // Type d'habilitation (ex: "FIRST_AID", "CHILDCARE", "ELDERLY_CARE")
  
  // Informations de l'habilitation
  title             String              // Titre de l'habilitation
  description       String?             // Description
  issuingAuthority  String              // Autorité délivrant l'habilitation
  
  // Statut et validation
  status            HabilitationStatus  @default(PENDING)
  
  // Documents justificatifs
  certificateUrl    String?             // URL du certificat
  documentUrls      String[]            // URLs des documents supplémentaires
  
  // Dates importantes
  issuedAt          DateTime?           // Date de délivrance
  expiresAt         DateTime?           // Date d'expiration
  validatedAt       DateTime?           // Date de validation par EcoDeli
  validatedBy       String?             // Admin qui a validé
  
  // Informations de renouvellement
  renewalRequired   Boolean             @default(false)
  renewalNoticeDays Int?                // Préavis de renouvellement en jours
  lastRenewalAt     DateTime?           // Dernier renouvellement
  
  // Métadonnées de validation
  validationNotes   String?             // Notes de validation
  rejectionReason   String?             // Raison du rejet
  
  // Métadonnées
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  // Relations
  provider          User                @relation("ProviderHabilitations", fields: [providerId], references: [id], onDelete: Cascade)
  validator         User?               @relation("HabilitationValidator", fields: [validatedBy], references: [id])
  
  // Services nécessitant cette habilitation
  requiredByServices ProviderServiceHabilitation[]

  @@index([providerId])
  @@index([status])
  @@index([habilitationType])
  @@index([expiresAt])
  @@map("provider_habilitations")
}

/// Association entre services et habilitations requises
model ProviderServiceHabilitation {
  id               String              @id @default(cuid())
  serviceId        String              // PersonalService ID
  habilitationId   String
  isRequired       Boolean             @default(true) // Obligatoire ou recommandée
  
  // Relations
  habilitation     ProviderHabilitation @relation(fields: [habilitationId], references: [id], onDelete: Cascade)

  @@unique([serviceId, habilitationId])
  @@index([serviceId])
  @@map("provider_service_habilitations")
}

/// Intervention effectuée par un prestataire
model ProviderIntervention {
  id                String              @id @default(cuid())
  providerId        String
  bookingId         String              @unique // Lié à une PersonalServiceBooking
  
  // Informations de l'intervention
  interventionType  InterventionType    @default(SCHEDULED)
  status            InterventionStatus  @default(SCHEDULED)
  
  // Planning
  scheduledStart    DateTime            // Début programmé
  scheduledEnd      DateTime            // Fin programmée
  actualStart       DateTime?           // Début réel
  actualEnd         DateTime?           // Fin réelle
  
  // Localisation
  address           String              // Adresse d'intervention
  lat               Float               // Latitude
  lng               Float               // Longitude
  travelTime        Int?                // Temps de trajet en minutes
  travelDistance    Float?              // Distance en km
  
  // Check-in/out
  checkedInAt       DateTime?           // Heure d'arrivée sur site
  checkedOutAt      DateTime?           // Heure de départ du site
  gpsCheckin        Json?               // Coordonnées GPS check-in {lat, lng}
  gpsCheckout       Json?               // Coordonnées GPS check-out {lat, lng}
  
  // Détails de l'intervention
  workDescription   String              @db.Text // Description du travail effectué
  materialUsed      Json?               // Matériaux utilisés (array)
  toolsUsed         Json?               // Outils utilisés (array)
  
  // Documentation
  beforePhotos      String[]            // Photos avant intervention
  duringPhotos      String[]            // Photos pendant intervention
  afterPhotos       String[]            // Photos après intervention
  signatureUrl      String?             // Signature du client
  completionProof   String?             // Preuve de réalisation
  
  // Problèmes et incidents
  issues            Json?               // Problèmes rencontrés (array)
  additionalWork    String?             // Travaux supplémentaires effectués
  extraCharges      Json?               // Frais supplémentaires détaillés
  
  // Facturation
  hoursWorked       Float?              // Heures travaillées
  quotedPrice       Decimal             @db.Decimal(8,2) // Prix devisé
  finalPrice        Decimal?            @db.Decimal(8,2) // Prix final
  invoiceGenerated  Boolean             @default(false)
  invoiceUrl        String?             // URL de la facture générée
  
  // Évaluation client
  clientSatisfaction Int?               // Note client sur 5
  clientFeedback    String?             // Commentaires client
  
  // Notes internes
  internalNotes     String?             // Notes internes du prestataire
  adminNotes        String?             // Notes administratives
  
  // Métadonnées
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  completedAt       DateTime?
  
  // Relations
  provider          User                @relation("ProviderInterventions", fields: [providerId], references: [id], onDelete: Cascade)
  evaluation        ProviderEvaluation? @relation("InterventionEvaluation")

  @@index([providerId])
  @@index([status])
  @@index([scheduledStart])
  @@index([interventionType])
  @@map("provider_interventions")
}

/// Évaluation détaillée d'un prestataire par un client
model ProviderEvaluation {
  id                String          @id @default(cuid())
  providerId        String
  clientId          String
  interventionId    String?         @unique // Intervention évaluée (optionnel)
  evaluationType    EvaluationType  @default(CLIENT_TO_PROVIDER)
  
  // Évaluation globale
  overallRating     Int             // Note globale sur 5
  comment           String?         @db.Text // Commentaire détaillé
  
  // Critères détaillés
  punctualityRating Int?            // Ponctualité sur 5
  qualityRating     Int?            // Qualité du travail sur 5
  communicationRating Int?          // Communication sur 5
  professionalismRating Int?        // Professionnalisme sur 5
  valueRating       Int?            // Rapport qualité/prix sur 5
  cleanlinessRating Int?            // Propreté sur 5
  
  // Recommandations
  wouldRecommend    Boolean?        // Recommanderait ce prestataire
  wouldRebook       Boolean?        // Re-ferait appel à ce prestataire
  strengths         String[]        // Points forts (tags)
  improvements      String[]        // Points d'amélioration (tags)
  
  // Réponse du prestataire
  providerResponse  String?         @db.Text // Réponse du prestataire
  providerResponseAt DateTime?      // Date de réponse
  
  // Modération et validation
  isVerified        Boolean         @default(false) // Évaluation vérifiée
  isPublic          Boolean         @default(true)  // Visible publiquement
  moderatedBy       String?         // Admin modérateur
  moderatedAt       DateTime?
  moderationNotes   String?         // Notes de modération
  
  // Impact sur le prestataire
  affectsRating     Boolean         @default(true) // Compte dans la note moyenne
  isDisplayed       Boolean         @default(true) // Affiché sur le profil
  
  // Métadonnées
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  // Relations
  provider          User            @relation("ProviderEvaluated", fields: [providerId], references: [id], onDelete: Cascade)
  client            User            @relation("ProviderEvaluator", fields: [clientId], references: [id], onDelete: Cascade)
  intervention      ProviderIntervention? @relation("InterventionEvaluation", fields: [interventionId], references: [id])
  moderator         User?           @relation("EvaluationModerator", fields: [moderatedBy], references: [id])

  @@index([providerId])
  @@index([clientId])
  @@index([overallRating])
  @@index([isPublic, affectsRating])
  @@index([createdAt])
  @@map("provider_evaluations")
}

/// Facturation automatique des prestataires
model ProviderAutoInvoicing {
  id                String              @id @default(cuid())
  providerId        String              @unique
  
  // Configuration
  status            AutoInvoicingStatus @default(DISABLED)
  billingDay        Int                 @default(1) // Jour du mois pour facturation (1-28)
  
  // Informations de facturation
  companyName       String?             // Nom de l'entreprise
  siretNumber       String?             // Numéro SIRET
  vatNumber         String?             // Numéro TVA
  billingAddress    Json?               // Adresse de facturation complète
  
  // Configuration de la facture
  invoiceTemplate   String?             // Template de facture utilisé
  includeDetails    Boolean             @default(true) // Inclure détails des interventions
  groupByService    Boolean             @default(false) // Grouper par type de service
  
  // Paramètres de paiement
  bankAccountIban   String?             // IBAN pour virement
  bankAccountBic    String?             // BIC
  paymentTerms      Int                 @default(30) // Délai de paiement en jours
  
  // Seuils et conditions
  minimumAmount     Decimal?            @db.Decimal(8,2) // Montant minimum pour facturation
  commissionRate    Decimal             @db.Decimal(5,4) @default(0.15) // Taux commission EcoDeli
  
  // Notifications
  emailNotifications Boolean            @default(true)
  smsNotifications  Boolean             @default(false)
  
  // Métadonnées
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  lastInvoiceDate   DateTime?           // Dernière facture générée
  nextInvoiceDate   DateTime?           // Prochaine facture prévue
  
  // Relations
  provider          User                @relation("ProviderAutoInvoicing", fields: [providerId], references: [id], onDelete: Cascade)
  
  // Historique des factures générées
  generatedInvoices ProviderMonthlyInvoice[]

  @@index([status])
  @@index([nextInvoiceDate])
  @@map("provider_auto_invoicing")
}

/// Facture mensuelle générée automatiquement
model ProviderMonthlyInvoice {
  id                String                @id @default(cuid())
  autoInvoicingId   String
  providerId        String
  
  // Période facturée
  periodMonth       Int                   // Mois (1-12)
  periodYear        Int                   // Année
  
  // Informations de la facture
  invoiceNumber     String                @unique // Numéro de facture auto-généré
  issueDate         DateTime              @default(now())
  dueDate           DateTime              // Date d'échéance
  
  // Montants
  totalEarnings     Decimal               @db.Decimal(10,2) // Gains totaux du prestataire
  platformCommission Decimal             @db.Decimal(8,2)  // Commission EcoDeli
  netAmount         Decimal               @db.Decimal(10,2) // Montant net à payer
  vatAmount         Decimal?              @db.Decimal(8,2)  // TVA si applicable
  
  // Détails des prestations
  interventionCount Int                   @default(0) // Nombre d'interventions
  hoursWorked       Float                 @default(0) // Heures travaillées
  averageRating     Float?                // Note moyenne de la période
  
  // Statut et paiement
  status            InvoiceStatus         @default(ISSUED)
  paidAt            DateTime?             // Date de paiement
  paymentMethod     String?               // Méthode de paiement
  
  // Fichiers
  pdfUrl            String?               // URL du PDF de facture
  detailsJson       Json?                 // Détails des interventions (JSON)
  
  // Métadonnées
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  
  // Relations
  autoInvoicing     ProviderAutoInvoicing @relation(fields: [autoInvoicingId], references: [id], onDelete: Cascade)
  provider          User                  @relation("ProviderMonthlyInvoices", fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([providerId, periodYear, periodMonth])
  @@index([autoInvoicingId])
  @@index([status])
  @@index([issueDate])
  @@map("provider_monthly_invoices")
}
// ===== MODÈLES DE SERVICES =====
// Ce fichier contient les modèles pour les services proposés par les prestataires.

/// Service proposé par un prestataire
model Service {
  id               String           @id @default(cuid())
  name             String
  description      String
  price            Decimal
  duration         Int              // Durée en minutes
  categoryId       String
  providerId       String
  isActive         Boolean          @default(true)
  isOnline         Boolean          @default(false)
  isAtHome         Boolean          @default(false)
  isAtShop         Boolean          @default(true)
  maxParticipants  Int?             // Nombre max de participants (pour cours/groupes)
  preparationTime  Int?             // Temps de préparation en minutes
  tags             String[]         // Tags pour recherche
  images           String[]         // URLs des images du service
  requirements     String?          // Prérequis ou matériel nécessaire
  cancellationPolicy String?        // Politique d'annulation
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  
  // Relations avec CategoryService, User et ServiceBooking
  category         ServiceCategory  @relation(fields: [categoryId], references: [id])
  provider         User             @relation(fields: [providerId], references: [id])
  bookings         ServiceBooking[]
  payments         Payment[]
  appointments     ClientAppointment[] @relation("ServiceAppointments")

  @@index([providerId])
  @@index([categoryId])
  @@index([isActive])
}

/// Catégorie de service
model ServiceCategory {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  icon        String?   // Icône pour l'affichage
  color       String?   // Couleur thématique
  isActive    Boolean   @default(true)
  sortOrder   Int       @default(0)
  parentId    String?   // Pour créer une hiérarchie de catégories
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  services    Service[]
  parent      ServiceCategory? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    ServiceCategory[] @relation("CategoryHierarchy")

  @@index([isActive, sortOrder])
  @@index([parentId])
} 
// ===== MODÈLES DE COMPÉTENCES DES PRESTATAIRES =====
// Ce fichier contient le modèle pour les compétences des prestataires de services.

/// Compétence d'un prestataire
model Skill {
  id          String   @id @default(cuid())
  providerId  String
  name        String
  description String?
  isVerified  Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations avec le profil prestataire
  provider    Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@index([providerId])
  @@map("skills")
} 

// ----- DOMAINE: APPOINTMENTS -----

// ===== MODÈLES RENDEZ-VOUS CLIENTS =====
// Ce fichier contient les modèles pour la gestion des rendez-vous entre clients et prestataires.

/// Rendez-vous entre un client et un prestataire
model ClientAppointment {
  id                String            @id @default(cuid())
  clientId          String
  providerId        String
  serviceId         String?           // Service associé (optionnel)
  bookingId         String?           // Réservation associée (optionnel)
  
  // Informations de base du rendez-vous
  title             String            // Titre/objet du rendez-vous
  description       String?           // Description détaillée
  startTime         DateTime          // Heure de début
  endTime           DateTime          // Heure de fin
  estimatedDuration Int               // Durée estimée en minutes
  actualStartTime   DateTime?         // Heure de début réelle
  actualEndTime     DateTime?         // Heure de fin réelle
  
  // Statut et état
  status            AppointmentStatus @default(PENDING)
  isRecurring       Boolean           @default(false)
  recurringRule     String?           // Règle de récurrence (format iCal RRULE)
  isVirtual         Boolean           @default(false)
  meetingLink       String?           // Lien pour rendez-vous virtuel
  
  // Localisation
  addressId         String?           // Adresse si rendez-vous physique
  locationNotes     String?           // Notes sur le lieu
  
  // Prix et paiement
  price             Decimal?          // Prix du rendez-vous
  paymentId         String?           // Paiement associé
  
  // Notes et communications
  clientNotes       String?           // Notes du client
  providerNotes     String?           // Notes privées du prestataire
  internalNotes     String?           // Notes internes système
  
  // Confirmation et rappels
  confirmationCode  String?           @unique // Code de confirmation
  requiresConfirmation Boolean        @default(true)
  confirmedAt       DateTime?         // Date de confirmation
  confirmedBy       String?           // Qui a confirmé (clientId ou providerId)
  
  // Notifications et rappels
  remindersSent     String[]          @default([]) // Types de rappels envoyés
  lastReminderSent  DateTime?         // Dernier rappel envoyé
  notificationsSent String[]          @default([]) // Notifications envoyées
  
  // Reprogrammation
  originalAppointmentId String?       // Rendez-vous original si reprogrammé
  rescheduleCount   Int               @default(0) // Nombre de reprogrammations
  rescheduleReason  RescheduleReason? // Raison de la reprogrammation
  rescheduleNotes   String?           // Notes sur la reprogrammation
  rescheduledBy     String?           // Qui a reprogrammé
  rescheduledAt     DateTime?         // Date de reprogrammation
  
  // Annulation
  cancelledAt       DateTime?         // Date d'annulation
  cancelledBy       String?           // Qui a annulé
  cancellationReason CancellationReason? // Raison d'annulation
  cancellationNotes String?           // Notes d'annulation
  refundAmount      Decimal?          // Montant remboursé
  cancellationFee   Decimal?          // Frais d'annulation
  
  // Suivi et évaluation
  completedAt       DateTime?         // Date de fin réelle
  noShowAt          DateTime?         // Date du non-show
  clientPresent     Boolean?          // Client présent
  providerPresent   Boolean?          // Prestataire présent
  hasReview         Boolean           @default(false) // A une évaluation
  
  // Métadonnées
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  version           Int               @default(1) // Version pour éviter conflits
  
  // Relations
  client            User              @relation("ClientAppointments", fields: [clientId], references: [id])
  provider          User              @relation("ProviderAppointments", fields: [providerId], references: [id])
  service           Service?          @relation("ServiceAppointments", fields: [serviceId], references: [id])
  booking           ServiceBooking?   @relation(fields: [bookingId], references: [id])
  address           Address?          @relation(fields: [addressId], references: [id])
  payment           Payment?          @relation("AppointmentPayments", fields: [paymentId], references: [id])
  
  // Relations de reprogrammation
  originalAppointment ClientAppointment? @relation("AppointmentReschedule", fields: [originalAppointmentId], references: [id])
  rescheduledAppointments ClientAppointment[] @relation("AppointmentReschedule")
  
  // Historique et notifications
  history           AppointmentHistory[]
  notifications     AppointmentNotification[]
  slots             AppointmentSlot[]
  
  // Index pour les performances
  @@index([clientId])
  @@index([providerId])
  @@index([serviceId])
  @@index([status])
  @@index([startTime])
  @@index([endTime])
  @@index([createdAt])
  @@index([confirmationCode])
  @@index([originalAppointmentId])
}

/// Historique des modifications d'un rendez-vous
model AppointmentHistory {
  id            String            @id @default(cuid())
  appointmentId String
  
  // Détails de la modification
  action        String            // Type d'action (CREATED, UPDATED, RESCHEDULED, etc.)
  changes       Json              // Détails des changements (format JSON)
  oldValues     Json?             // Anciennes valeurs
  newValues     Json?             // Nouvelles valeurs
  reason        String?           // Raison du changement
  
  // Qui a effectué le changement
  changedBy     String?           // ID de l'utilisateur
  changedByRole String?           // Rôle (CLIENT, PROVIDER, SYSTEM)
  userAgent     String?           // User agent pour traçabilité
  ipAddress     String?           // Adresse IP
  
  // Métadonnées
  createdAt     DateTime          @default(now())
  
  // Relations
  appointment   ClientAppointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  user          User?             @relation("AppointmentHistoryUser", fields: [changedBy], references: [id])
  
  // Index
  @@index([appointmentId])
  @@index([createdAt])
  @@index([action])
}

/// Notifications liées aux rendez-vous
model AppointmentNotification {
  id            String                      @id @default(cuid())
  appointmentId String
  
  // Type et contenu
  type          AppointmentNotificationType
  title         String
  message       String
  
  // Destinataire
  recipientId   String                      // Client ou prestataire
  recipientType String                      // CLIENT ou PROVIDER
  
  // Statut d'envoi
  sent          Boolean                     @default(false)
  sentAt        DateTime?
  deliveredAt   DateTime?
  readAt        DateTime?
  
  // Canaux d'envoi
  channels      String[]                    @default([]) // EMAIL, SMS, PUSH, IN_APP
  
  // Programmation
  scheduledFor  DateTime?                   // Pour les rappels programmés
  
  // Erreurs
  failed        Boolean                     @default(false)
  failureReason String?
  retryCount    Int                         @default(0)
  lastRetryAt   DateTime?
  
  // Métadonnées
  createdAt     DateTime                    @default(now())
  updatedAt     DateTime                    @updatedAt
  
  // Relations
  appointment   ClientAppointment           @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  recipient     User                        @relation("AppointmentNotificationUser", fields: [recipientId], references: [id])
  
  // Index
  @@index([appointmentId])
  @@index([recipientId])
  @@index([type])
  @@index([scheduledFor])
  @@index([sent])
  @@index([createdAt])
}

/// Disponibilités spécifiques pour les rendez-vous
model AppointmentSlot {
  id          String            @id @default(cuid())
  providerId  String
  
  // Créneau
  startTime   DateTime
  endTime     DateTime
  duration    Int               // Durée en minutes
  
  // Statut
  isAvailable Boolean           @default(true)
  isBlocked   Boolean           @default(false)
  blockReason String?           // Raison du blocage
  
  // Réservation
  isBooked    Boolean           @default(false)
  bookedBy    String?           // ID du client qui a réservé
  appointmentId String?         @unique // Rendez-vous associé
  
  // Récurrence
  isRecurring Boolean           @default(false)
  recurringRule String?         // Règle de récurrence
  parentSlotId String?          // Slot parent si récurrence
  
  // Prix et conditions
  price       Decimal?          // Prix spécifique pour ce créneau
  minNotice   Int?              // Préavis minimum en heures
  maxAdvance  Int?              // Réservation maximum à l'avance en jours
  
  // Métadonnées
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  
  // Relations
  provider    User              @relation("ProviderAppointmentSlots", fields: [providerId], references: [id])
  client      User?             @relation("ClientReservedSlots", fields: [bookedBy], references: [id])
  appointment ClientAppointment? @relation(fields: [appointmentId], references: [id])
  parentSlot  AppointmentSlot?  @relation("SlotRecurrence", fields: [parentSlotId], references: [id])
  childSlots  AppointmentSlot[] @relation("SlotRecurrence")
  
  // Index
  @@index([providerId])
  @@index([startTime])
  @@index([endTime])
  @@index([isAvailable])
  @@index([isBooked])
  @@index([bookedBy])
}

/// Règles de disponibilité des prestataires pour les rendez-vous
model AppointmentAvailabilityRule {
  id          String    @id @default(cuid())
  providerId  String
  
  // Règle de disponibilité
  name        String    // Nom de la règle
  description String?   // Description
  
  // Jours de la semaine (0 = dimanche, 6 = samedi)
  daysOfWeek  Int[]     // [1,2,3,4,5] pour lun-ven
  
  // Heures
  startTime   String    // Format HH:mm
  endTime     String    // Format HH:mm
  timezone    String    @default("Europe/Paris")
  
  // Durée et espacement
  slotDuration Int      // Durée en minutes
  breakBetween Int      @default(0) // Pause entre créneaux en minutes
  
  // Limites
  maxAppointmentsPerDay Int? // Limite d'appointments par jour
  minNoticeHours Int    @default(24) // Préavis minimum
  maxAdvanceDays Int    @default(30) // Réservation max à l'avance
  
  // Période d'application
  validFrom   DateTime  // Date de début
  validTo     DateTime? // Date de fin (optionnelle)
  
  // État
  isActive    Boolean   @default(true)
  priority    Int       @default(0) // Priorité en cas de conflit
  
  // Métadonnées
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  provider    User      @relation("ProviderAvailabilityRules", fields: [providerId], references: [id])
  
  // Index
  @@index([providerId])
  @@index([daysOfWeek])
  @@index([validFrom])
  @@index([isActive])
}

/// Exceptions aux règles de disponibilité
model AppointmentAvailabilityException {
  id          String        @id @default(cuid())
  providerId  String
  
  // Exception
  date        DateTime      // Date de l'exception
  startTime   String?       // Heure de début (format HH:mm) - null = toute la journée
  endTime     String?       // Heure de fin (format HH:mm)
  
  // Type d'exception
  type        ExceptionType
  reason      String        // Raison de l'exception
  description String?       // Description détaillée
  
  // État
  isBlocked   Boolean       @default(true) // Bloque ou libère
  
  // Métadonnées
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  // Relations
  provider    User          @relation("ProviderAvailabilityExceptions", fields: [providerId], references: [id])
  
  // Index
  @@index([providerId])
  @@index([date])
  @@index([type])
} 

// ----- DOMAINE: STORAGE -----

// ===== MODÈLES DE BOX DE STOCKAGE =====
// Ce fichier contient le modèle pour les boxes de stockage disponibles dans les entrepôts.

/// Box de stockage disponible dans un entrepôt
model Box {
  id                  String                        @id @default(cuid())
  warehouseId         String
  name                String
  size                Float
  boxType             BoxType                       @default(STANDARD)
  isOccupied          Boolean                       @default(false)
  clientId            String?
  pricePerDay         Float
  description         String?
  locationDescription String?
  floorLevel          Int                           @default(0)
  maxWeight           Float?
  dimensions          Json?
  features            String[]
  status              BoxStatus                     @default(AVAILABLE)
  lastInspectedAt     DateTime?
  createdAt           DateTime                      @default(now())
  updatedAt           DateTime                      @updatedAt
  
  // Relations avec User, Warehouse et les réservations
  client              User?                         @relation(fields: [clientId], references: [id])
  warehouse           Warehouse                     @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  reservations        Reservation[]
  subscriptions       BoxAvailabilitySubscription[]
  usageHistory        BoxUsageHistory[]

  @@index([warehouseId])
  @@index([clientId])
  @@index([status])
  @@map("boxes")
} 
// ===== MODÈLES DE RÉSERVATION DE BOX =====
// Ce fichier contient les modèles pour les réservations de boxes de stockage.

/// Réservation d'une box par un client
model Reservation {
  id              String            @id @default(cuid())
  boxId           String
  clientId        String
  startDate       DateTime
  endDate         DateTime
  status          ReservationStatus @default(ACTIVE)
  totalPrice      Float
  paymentStatus   PaymentStatus     @default(PENDING)
  paymentId       String?
  accessCode      String?
  lastAccessed    DateTime?
  notes           String?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  cancelledAt     DateTime?
  cancelReason    String?
  extendedCount   Int               @default(0)
  originalEndDate DateTime?
  
  // Relations
  usageHistory    BoxUsageHistory[]
  box             Box               @relation(fields: [boxId], references: [id], onDelete: Cascade)
  client          User              @relation(fields: [clientId], references: [id])

  @@index([boxId])
  @@index([clientId])
  @@index([status])
  @@map("reservations")
} 
// ===== MODÈLES D'ABONNEMENT AUX BOXES =====
// Ce fichier contient le modèle pour les abonnements aux notifications de disponibilité.

/// Abonnement pour être notifié quand une box devient disponible
model BoxAvailabilitySubscription {
  id                      String    @id @default(cuid())
  boxId                   String
  clientId                String
  startDate               DateTime?
  endDate                 DateTime?
  minSize                 Float?
  maxPrice                Float?
  boxType                 BoxType?
  warehouseId             String?
  isActive                Boolean   @default(true)
  notificationPreferences Json?
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  lastNotified            DateTime?
  
  // Relations
  box                     Box       @relation(fields: [boxId], references: [id], onDelete: Cascade)
  client                  User      @relation(fields: [clientId], references: [id])

  @@index([boxId])
  @@index([clientId])
  @@map("box_availability_subscriptions")
} 
// ===== MODÈLES D'HISTORIQUE D'UTILISATION =====
// Ce fichier contient le modèle pour le suivi des actions sur les boxes.

/// Historique d'utilisation d'une box
model BoxUsageHistory {
  id            String        @id @default(cuid())
  boxId         String
  reservationId String?
  clientId      String
  actionType    BoxActionType
  actionTime    DateTime      @default(now())
  details       String?
  ipAddress     String?
  deviceInfo    String?
  
  // Relations
  box           Box           @relation(fields: [boxId], references: [id], onDelete: Cascade)
  client        User          @relation(fields: [clientId], references: [id])
  reservation   Reservation?  @relation(fields: [reservationId], references: [id])

  @@index([boxId])
  @@index([reservationId])
  @@index([clientId])
  @@map("box_usage_history")
} 
// ===== MODÈLES D'ENTREPÔT DE STOCKAGE =====
// Ce fichier contient le modèle principal pour les entrepôts où sont stockées les boxes.

/// Entrepôt physique où se trouvent les boxes de stockage
model Warehouse {
  id             String   @id @default(cuid())
  name           String
  location       String
  address        String
  capacity       Float
  occupied       Float    @default(0)
  description    String?
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  latitude       Float?
  longitude      Float?
  openingHours   Json?
  contactPhone   String?
  contactEmail   String?
  imageUrl       String?
  availableBoxes Int      @default(0)
  reservedBoxes  Int      @default(0)
  
  // Relations
  boxes          Box[]

  @@map("warehouses")
} 

// ----- DOMAINE: PAYMENTS -----

// ===== MODÈLES DE PAIEMENT =====
// Ce fichier contient le modèle pour les paiements effectués sur la plateforme.

/// Paiement réalisé sur la plateforme
model Payment {
  id                 String           @id @default(cuid())
  amount             Decimal
  currency           String
  status             PaymentStatus
  description        String?
  userId             String
  isEscrow           Boolean          @default(false)
  escrowReleaseCode  String?
  escrowReleaseDate  DateTime?
  escrowReleasedAt   DateTime?
  stripePaymentId    String?
  paymentIntentId    String?
  deliveryId         String?          @unique
  serviceId          String?
  subscriptionId     String?
  invoiceId          String?
  commissionAmount   Decimal?
  commissionId       String?
  refundId           String?
  refundedAmount     Decimal?
  refundedAt         DateTime?
  disputeId          String?
  disputeStatus      String?
  metadata           Json?
  capturedAt         DateTime?
  paymentMethodType  String?
  paymentMethodId    String?
  receiptUrl         String?
  errorMessage       String?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  source             String?
  notes              String?
  paymentProvider    String           @default("STRIPE")
  isRecurring        Boolean          @default(false)
  recurringFrequency String?
  processingFee      Decimal?
  taxAmount          Decimal?
  taxRate            Decimal?
  paymentReference   String?
  ipAddress          String?
  
  // Relations
  bookings           ServiceBooking[]
  commission         Commission?      @relation(fields: [commissionId], references: [id])
  delivery           Delivery?        @relation("PaymentToDelivery", fields: [deliveryId], references: [id])
  invoice            Invoice?         @relation(fields: [invoiceId], references: [id])
  service            Service?         @relation(fields: [serviceId], references: [id])
  subscription       Subscription?    @relation(fields: [subscriptionId], references: [id])
  user               User             @relation(fields: [userId], references: [id])
  appointments       ClientAppointment[] @relation("AppointmentPayments")

  @@index([userId])
  @@index([deliveryId])
  @@index([serviceId])
  @@index([subscriptionId])
  @@index([invoiceId])
  @@index([commissionId])
  @@map("payments")
} 
// ===== MODÈLES D'ABONNEMENT ET MOYENS DE PAIEMENT =====
// Ce fichier contient les modèles pour les abonnements et méthodes de paiement.

/// Abonnement à un plan de la plateforme
model Subscription {
  id                     String             @id @default(cuid())
  userId                 String
  status                 SubscriptionStatus
  planType               PlanType
  stripeSubscriptionId   String?
  startDate              DateTime
  endDate                DateTime?
  autoRenew              Boolean            @default(true)
  cancelAtPeriodEnd      Boolean            @default(false)
  cancelledAt            DateTime?
  currentPeriodStart     DateTime?
  currentPeriodEnd       DateTime?
  discountPercent        Decimal?
  previousPlanType       PlanType?
  billingCycleAnchor     Int?
  couponApplied          String?
  createdAt              DateTime           @default(now())
  currency               String             @default("EUR")
  customPlanFeatures     Json?
  discountAmount         Decimal?
  discountDuration       String?
  discountDurationMonths Int?
  downgradedAt           DateTime?
  gracePeriodEnd         DateTime?
  lastPaymentFailure     DateTime?
  metadata               Json?
  nextInvoiceDate        DateTime?
  pausedAt               DateTime?
  paymentFailureCount    Int                @default(0)
  price                  Decimal?
  resumeAt               DateTime?
  trialEnd               DateTime?
  trialStart             DateTime?
  updatedAt              DateTime           @updatedAt
  upgradedAt             DateTime?
  
  // Relations
  payments               Payment[]
  user                   User               @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
  @@map("subscriptions")
}

/// Moyen de paiement enregistré par un utilisateur
model PaymentMethod {
  id               String    @id @default(cuid())
  userId           String
  type             String
  isDefault        Boolean   @default(false)
  brand            String?
  last4            String?
  expiryMonth      Int?
  expiryYear       Int?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  billingAddress   String?
  billingCity      String?
  billingCountry   String?
  billingEmail     String?
  billingName      String?
  billingPostal    String?
  billingState     String?
  deletedAt        DateTime?
  fingerprint      String?
  isDeleted        Boolean   @default(false)
  mandateCreatedAt DateTime?
  mandateId        String?
  mandateStatus    String?
  provider         String    @default("STRIPE")
  token            String
  
  // Relations
  user             User      @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([isDefault])
  @@map("payment_methods")
} 
// ===== MODÈLES DE PORTEFEUILLE ÉLECTRONIQUE =====
// Ce fichier contient les modèles pour les portefeuilles des livreurs et prestataires
// et les transactions associées.

/// Portefeuille électronique d'un utilisateur
model Wallet {
  id                      String              @id @default(cuid())
  userId                  String              @unique
  balance                 Decimal             @default(0)
  currency                String              @default("EUR")
  isActive                Boolean             @default(true)
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt
  lastTransactionAt       DateTime?
  accountVerified         Boolean             @default(false)
  accountType             String?
  minimumWithdrawalAmount Decimal             @default(10)
  automaticWithdrawal     Boolean             @default(false)
  withdrawalThreshold     Decimal?
  withdrawalDay           Int?
  totalEarned             Decimal?
  totalWithdrawn          Decimal?
  earningsLastMonth       Decimal?
  earningsThisMonth       Decimal?
  encryptedBankInfo       String?
  fiscalCategory          String?
  lastWithdrawalAt        DateTime?
  notificationThreshold   Decimal?
  notificationsEnabled    Boolean             @default(true)
  stripeConnectAccountId  String?
  stripeCustomerId        String?
  taxIdentifier           String?
  taxReportingEnabled     Boolean             @default(false)
  
  // Relations
  transactions            WalletTransaction[]
  user                    User                @relation(fields: [userId], references: [id])
  withdrawalRequests      WithdrawalRequest[]

  @@map("wallets")
}

/// Transaction dans un portefeuille
model WalletTransaction {
  id                String            @id @default(cuid())
  walletId          String
  amount            Decimal
  currency          String
  type              TransactionType
  status            TransactionStatus @default(PENDING)
  description       String?
  reference         String?
  stripeTransferId  String?
  metadata          Json?
  createdAt         DateTime          @default(now())
  balanceAfter      Decimal?
  commissionRate    Decimal?
  completedAt       DateTime?
  deliveryId        String?
  failedAt          DateTime?
  failureReason     String?
  isSystemGenerated Boolean           @default(false)
  paymentId         String?
  previousBalance   Decimal?
  reportingCategory String?
  serviceId         String?
  sourceTransaction String?
  taxAmount         Decimal?
  taxRate           Decimal?
  updatedAt         DateTime          @updatedAt
  withdrawalId      String?
  
  // Relations
  wallet            Wallet            @relation(fields: [walletId], references: [id])

  @@index([walletId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@map("wallet_transactions")
} 
// ===== MODÈLES DE RETRAIT ET TRANSFERT BANCAIRE =====
// Ce fichier contient les modèles pour les demandes de retrait et transferts bancaires.

/// Demande de retrait d'argent
model WithdrawalRequest {
  id                  String           @id @default(cuid())
  walletId            String
  amount              Decimal
  currency            String
  status              WithdrawalStatus @default(PENDING)
  requestedAt         DateTime         @default(now())
  processedAt         DateTime?
  rejectionReason     String?
  preferredMethod     String?
  reference           String?
  accountVerified     Boolean          @default(true)
  estimatedArrival    DateTime?
  estimatedFee        Decimal?
  expedited           Boolean          @default(false)
  lastNotificationAt  DateTime?
  priority            Int              @default(0)
  processorComments   String?
  processorId         String?
  reviewRequired      Boolean          @default(false)
  supportingDocuments String[]
  taxWithheld         Decimal?
  
  // Relations
  bankTransfer        BankTransfer?
  wallet              Wallet           @relation(fields: [walletId], references: [id])

  @@index([walletId])
  @@index([status])
  @@index([requestedAt])
  @@map("withdrawal_requests")
}

/// Transfert bancaire suite à une demande de retrait
model BankTransfer {
  id                    String             @id @default(cuid())
  amount                Decimal
  currency              String
  withdrawalRequestId   String?            @unique
  recipientName         String
  bankName              String?
  reference             String?
  initiatedAt           DateTime
  completedAt           DateTime?
  failedAt              DateTime?
  failureReason         String?
  notes                 String?
  metadata              Json?
  createdBy             String?
  endorsedBy            String?
  estimatedArrivalDate  DateTime?
  externalReference     String?
  isRecipientVerified   Boolean            @default(false)
  isSenderVerified      Boolean            @default(true)
  platformTransactionId String?
  recipientBic          String?
  recipientIban         String
  senderIban            String?
  senderName            String?
  transferFee           Decimal?
  transferMethod        String             @default("SEPA")
  transferProofUrl      String?
  transferReference     String?
  status                TransactionStatus
  
  // Relations
  withdrawalRequest     WithdrawalRequest? @relation(fields: [withdrawalRequestId], references: [id])

  @@map("bank_transfers")
} 

// ----- DOMAINE: BILLING -----

// ===== MODÈLES DE COMPTES FINANCIERS =====
// Ce fichier contient les modèles pour les comptes financiers et taux de taxes.

/// Compte financier de la plateforme
model FinancialAccount {
  id                 String    @id @default(cuid())
  name               String
  accountType        String
  balance            Decimal   @default(0)
  currency           String    @default("EUR")
  description        String?
  isActive           Boolean   @default(true)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  reconciliationDate DateTime?
  bankAccount        String?
  accountNumber      String?
  notes              String?

  @@map("financial_accounts")
}

/// Taux de taxe applicable
model TaxRate {
  id          String    @id @default(cuid())
  name        String
  rate        Decimal
  countryCode String
  description String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  taxType     String    @default("VAT")
  region      String?
  startDate   DateTime?
  endDate     DateTime?

  @@index([countryCode])
  @@index([isActive])
  @@map("tax_rates")
} 
// ===== MODÈLES DE COMMISSIONS =====
// Ce fichier contient les modèles pour les commissions et promotions.

/// Commission appliquée sur les transactions
model Commission {
  id              String    @id @default(cuid())
  rate            Decimal
  promotionId     String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  applicableRoles String[]
  calculationType String    @default("PERCENTAGE")
  countryCode     String?
  currency        String    @default("EUR")
  description     String?
  endDate         DateTime?
  flatFee         Decimal?
  isActive        Boolean   @default(true)
  maximumAmount   Decimal?
  minimumAmount   Decimal?
  payoutSchedule  String?   @default("IMMEDIATE")
  productCategory String?
  serviceType     String
  startDate       DateTime?
  tierThresholds  Json?
  
  // Relations
  payments        Payment[]

  @@index([serviceType])
  @@index([isActive])
  @@map("commissions")
}

/// Enregistrement des promotions
model PromotionRecord {
  id          String   @id @default(cuid())
  type        String
  serviceType String?
  rate        Decimal
  startDate   DateTime
  endDate     DateTime
  isActive    Boolean  @default(true)
  description String?
  createdAt   DateTime @default(now())

  @@map("promotion_records")
} 
// ===== MODÈLES DE CYCLES DE FACTURATION =====
// Ce fichier contient le modèle pour les cycles de facturation automatisés.

/// Cycle de facturation pour les commerçants et prestataires
model BillingCycle {
  id               String    @id @default(cuid())
  merchantId       String?
  providerId       String?
  contractId       String?
  periodStart      DateTime
  periodEnd        DateTime
  status           String    @default("PENDING")
  invoiceId        String?
  totalAmount      Decimal?
  serviceFees      Decimal?
  commissionFees   Decimal?
  processingFees   Decimal?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  scheduledRunDate DateTime
  serviceSummary   Json?
  lastRunAt        DateTime?
  errorMessage     String?
  retryCount       Int       @default(0)

  // Relations
  contract         Contract? @relation(fields: [contractId], references: [id])

  @@index([periodStart, periodEnd])
  @@index([status])
  @@index([contractId])
  @@map("billing_cycles")
} 
// ===== MODÈLES DE FACTURATION =====
// Ce fichier contient les modèles pour les factures et leurs lignes.

/// Facture émise par la plateforme
model Invoice {
  id                 String        @id @default(cuid())
  userId             String
  amount             Decimal
  currency           String        @default("EUR")
  status             InvoiceStatus
  dueDate            DateTime
  paidDate           DateTime?
  pdfUrl             String?
  billingPeriodStart DateTime?
  billingPeriodEnd   DateTime?
  paymentTerms       String?
  notes              String?
  companyName        String?
  billingAddress     String?
  billingCity        String?
  billingCountry     String?
  billingName        String?
  billingPostal      String?
  billingState       String?
  createdAt          DateTime      @default(now())
  description        String?
  emailSentAt        DateTime?
  invoiceNumber      String        @unique
  invoiceType        String        @default("SERVICE")
  isCreditNote       Boolean       @default(false)
  issueDate          DateTime
  locale             String        @default("fr")
  merchantId         String?
  originalInvoiceId  String?
  providerId         String?
  refundReason       String?
  reminderSentAt     DateTime?
  remoteStorageUrl   String?
  serviceDescription String?
  taxAmount          Decimal?
  taxId              String?
  taxRate            Decimal?
  termsAndConditions String?
  totalAmount        Decimal
  updatedAt          DateTime      @updatedAt
  
  // Relations
  items              InvoiceItem[]
  user               User          @relation(fields: [userId], references: [id])
  payments           Payment[]

  @@index([userId])
  @@index([status])
  @@index([issueDate])
  @@map("invoices")
}

/// Ligne de facture
model InvoiceItem {
  id          String    @id @default(cuid())
  invoiceId   String
  description String
  quantity    Decimal
  unitPrice   Decimal
  taxRate     Decimal?
  taxAmount   Decimal?
  serviceId   String?
  deliveryId  String?
  discount    Decimal?
  amount      Decimal
  createdAt   DateTime  @default(now())
  itemCode    String?
  metadata    Json?
  periodEnd   DateTime?
  periodStart DateTime?
  updatedAt   DateTime  @updatedAt
  
  // Relations
  invoice     Invoice   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@map("invoice_items")
} 
// ===== MODÈLES DE RAPPORTS FINANCIERS =====
// Ce fichier contient les modèles pour les rapports financiers et tâches associées.

/// Rapport financier généré par la plateforme
model FinancialReport {
  id               String   @id @default(cuid())
  data             Json?
  totalRevenue     Decimal?
  totalCommissions Decimal?
  status           String   @default("DRAFT")
  generatedAt      DateTime @default(now())
  fileUrl          String?
  generatedBy      String?
  netRevenue       Decimal?
  notes            String?
  periodEnd        DateTime
  periodStart      DateTime
  reportType       String
  totalFees        Decimal?

  @@index([reportType])
  @@index([periodStart, periodEnd])
  @@map("financial_reports")
}

/// Tâche financière à effectuer
model FinancialTask {
  id          String                @id @default(cuid())
  title       String
  description String?
  dueDate     DateTime?
  completed   Boolean               @default(false)
  completedAt DateTime?
  priority    FinancialTaskPriority
  category    FinancialTaskCategory
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  userId      String
  
  // Relations
  user        User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([priority])
  @@index([category])
  @@index([completed])
  @@map("financial_tasks")
} 

// ----- DOMAINE: MERCHANT -----

// ===== MODÈLES LÂCHER DE CHARIOT =====
// Ce fichier contient les modèles pour l'intégration caisse et le lâcher de chariot selon le cahier des charges

/// Configuration d'intégration caisse pour un commerçant
model MerchantCashRegister {
  id                String    @id @default(cuid())
  merchantId        String    @unique
  
  // Informations de l'intégration
  cashRegisterType  String    // Type de caisse (ex: "SAGE", "CEGID", "CUSTOM")
  apiEndpoint       String?   // Endpoint API de la caisse
  apiKey            String?   // Clé API (chiffrée)
  webhookUrl        String?   // URL de webhook pour notifications
  
  // Configuration technique
  isActive          Boolean   @default(false)
  lastSync          DateTime? // Dernière synchronisation
  syncFrequency     Int       @default(5) // Fréquence de sync en minutes
  
  // Paramètres du lâcher de chariot
  autoCreateDelivery Boolean  @default(true) // Création automatique annonce livraison
  defaultRadius     Float     @default(10) // Rayon de livraison par défaut en km
  deliveryTimeSlots Json?     // Créneaux de livraison disponibles
  
  // Groupage par zone
  enableZoneGrouping Boolean  @default(true) // Groupage par zone activé
  maxGroupSize      Int       @default(5) // Taille max du groupe
  groupingRadius    Float     @default(2) // Rayon de groupage en km
  
  // Notifications
  notifyCustomer    Boolean   @default(true) // Notifier le client
  notifyMerchant    Boolean   @default(true) // Notifier le commerçant
  
  // Métadonnées
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  merchant          Merchant  @relation("MerchantCashRegister", fields: [merchantId], references: [id], onDelete: Cascade)
  
  // Transactions de lâcher de chariot
  cartDrops         CartDrop[]
  
  // Terminaux associés
  terminals         CashRegisterTerminal[] @relation("CashRegisterTerminals")

  @@index([isActive])
  @@map("merchant_cash_registers")
}

/// Transaction de lâcher de chariot
model CartDrop {
  id                  String          @id @default(cuid())
  cashRegisterId      String
  merchantId          String
  
  // Informations de la transaction
  transactionId       String          @unique // ID transaction caisse
  receiptNumber       String?         // Numéro de ticket de caisse
  
  // Client et commande
  customerName        String?         // Nom du client
  customerPhone       String?         // Téléphone du client
  customerEmail       String?         // Email du client
  userId              String?         // User ID si client connecté
  
  // Détails de la commande
  items               Json            // Articles commandés (array)
  totalAmount         Decimal         @db.Decimal(8,2) // Montant total
  deliveryFee         Decimal         @db.Decimal(6,2) // Frais de livraison
  
  // Livraison
  deliveryAddress     String          // Adresse de livraison
  deliveryLat         Float           // Latitude livraison
  deliveryLng         Float           // Longitude livraison
  deliveryInstructions String?        // Instructions de livraison
  
  // Planning
  type                CartDropType    @default(INSTANT)
  status              CartDropStatus  @default(PENDING)
  requestedDeliveryTime DateTime?     // Créneau demandé
  confirmedDeliveryTime DateTime?     // Créneau confirmé
  
  // Groupage
  groupId             String?         // ID du groupe si groupé
  groupPosition       Int?            // Position dans le groupe
  isGroupLead         Boolean         @default(false) // Premier du groupe
  
  // Suivi
  preparationTime     Int?            // Temps de préparation en minutes
  readyAt             DateTime?       // Prêt pour livraison
  pickedUpAt          DateTime?       // Récupéré par livreur
  deliveredAt         DateTime?       // Livré au client
  
  // Assignment
  assignedDelivererId String?         // Livreur assigné
  assignedAt          DateTime?       // Date d'assignation
  deliveryCode        String?         // Code de validation livraison
  
  // Paiement et facturation
  isPaid              Boolean         @default(false)
  paymentMethod       String?         // Méthode de paiement
  paidAt              DateTime?
  merchantCommission  Decimal?        @db.Decimal(6,2) // Commission du commerçant
  
  // Métadonnées
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  completedAt         DateTime?
  
  // Relations
  cashRegister        MerchantCashRegister @relation(fields: [cashRegisterId], references: [id], onDelete: Restrict)
  merchant            Merchant        @relation("MerchantCartDrops", fields: [merchantId], references: [id], onDelete: Cascade)
  customer            User?           @relation("CartDropCustomer", fields: [userId], references: [id])
  assignedDeliverer   User?           @relation("CartDropDeliverer", fields: [assignedDelivererId], references: [id])
  
  // Groupe de livraison
  group               CartDropGroup?  @relation(fields: [groupId], references: [id])

  @@index([cashRegisterId])
  @@index([merchantId])
  @@index([status])
  @@index([groupId])
  @@index([requestedDeliveryTime])
  @@map("cart_drops")
}

/// Groupe de livraisons pour optimisation
model CartDropGroup {
  id                String          @id @default(cuid())
  merchantId        String
  
  // Informations du groupe
  title             String          // Titre du groupe (ex: "Groupe Zone Nord 14h")
  deliveryZone      String          // Zone de livraison
  centerLat         Float           // Latitude centre du groupe
  centerLng         Float           // Longitude centre du groupe
  radius            Float           // Rayon du groupe en km
  
  // Planning
  scheduledTime     DateTime        // Heure de livraison programmée
  status            CartDropStatus  @default(PENDING)
  
  // Capacités
  maxItems          Int             @default(5) // Nombre max de commandes
  currentItems      Int             @default(0) // Nombre actuel
  totalWeight       Float?          // Poids total estimé
  totalVolume       Float?          // Volume total estimé
  
  // Assignment
  assignedDelivererId String?       // Livreur assigné au groupe
  assignedAt        DateTime?       // Date d'assignation
  
  // Optimisation de route
  optimizedRoute    Json?           // Route optimisée (array d'étapes)
  estimatedDuration Int?            // Durée estimée en minutes
  estimatedDistance Float?          // Distance estimée en km
  
  // Suivi
  startedAt         DateTime?       // Début de la tournée
  completedAt       DateTime?       // Fin de la tournée
  
  // Métadonnées
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  // Relations
  merchant          Merchant        @relation("MerchantCartDropGroups", fields: [merchantId], references: [id], onDelete: Cascade)
  assignedDeliverer User?           @relation("CartDropGroupDeliverer", fields: [assignedDelivererId], references: [id])
  
  // Commandes du groupe
  cartDrops         CartDrop[]

  @@index([merchantId])
  @@index([status])
  @@index([scheduledTime])
  @@map("cart_drop_groups")
}

/// Configuration des zones de livraison pour un commerçant
model MerchantDeliveryZone {
  id            String    @id @default(cuid())
  merchantId    String
  
  // Informations de la zone
  name          String    // Nom de la zone (ex: "Centre-ville", "Zone Nord")
  description   String?   // Description
  
  // Géométrie de la zone
  coordinates   Json      // Polygone définissant la zone (array de {lat, lng})
  centerLat     Float     // Latitude du centre
  centerLng     Float     // Longitude du centre
  radius        Float?    // Rayon approximatif en km
  
  // Paramètres de livraison
  deliveryFee   Decimal   @db.Decimal(6,2) // Frais de livraison pour cette zone
  freeThreshold Decimal?  @db.Decimal(8,2) // Seuil de gratuité
  maxDeliveryTime Int     @default(60) // Temps max de livraison en minutes
  
  // Disponibilité
  isActive      Boolean   @default(true)
  timeSlots     Json?     // Créneaux disponibles par jour
  
  // Priorité et groupage
  priority      Int       @default(0) // Priorité de la zone
  groupingEnabled Boolean @default(true) // Groupage activé
  minGroupSize  Int       @default(2) // Taille min du groupe
  
  // Métadonnées
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  merchant      Merchant  @relation("MerchantDeliveryZones", fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
  @@index([isActive])
  @@map("merchant_delivery_zones")
}

/// Terminal de caisse physique
model CashRegisterTerminal {
  id                String             @id @default(cuid())
  cashRegisterId    String
  
  // Informations du terminal
  terminalName      String             // Nom du terminal
  terminalId        String             // ID unique du terminal
  location          String?            // Emplacement dans le magasin
  
  // Configuration
  isActive          Boolean            @default(true)
  softwareVersion   String?            // Version du logiciel
  lastHeartbeat     DateTime?          // Dernière connexion
  
  // Paramètres d'affichage
  displayCartDrop   Boolean            @default(true) // Afficher option lâcher chariot
  autoSuggestDelivery Boolean          @default(true) // Suggérer automatiquement
  
  // Statistiques
  dailyTransactions Int                @default(0) // Transactions du jour
  cartDropRequests  Int                @default(0) // Demandes lâcher chariot
  
  // Métadonnées
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  // Relations
  cashRegister      MerchantCashRegister @relation("CashRegisterTerminals", fields: [cashRegisterId], references: [id], onDelete: Cascade)

  @@unique([cashRegisterId, terminalId])
  @@index([isActive])
  @@map("cash_register_terminals")
}

// ----- DOMAINE: ADMIN -----

// ===== MODÈLES D'AUDIT ET TRAÇABILITÉ =====
// Ce fichier contient les modèles pour l'audit et le suivi de l'activité des utilisateurs.

/// Journaux d'audit des actions administratives
model AuditLog {
  id            String   @id @default(cuid())
  entityType    String
  entityId      String
  action        String
  performedById String
  changes       Json?
  createdAt     DateTime @default(now())
  
  // Relations
  performedBy   User     @relation("AuditLogPerformer", fields: [performedById], references: [id])

  @@map("audit_logs")
}

/// Journal d'activité utilisateur pour audit
model UserActivityLog {
  id           String       @id @default(cuid())
  userId       String
  activityType ActivityType
  details      String?
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime     @default(now())
  
  // Relations
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_activity_logs")
} 
// ===== MODÈLES DE CONTRATS =====
// Ce fichier contient le modèle pour les contrats entre commerçants et la plateforme.

/// Contrat conclu avec un commerçant
model Contract {
  id            String         @id @default(cuid())
  contractNumber String?        @unique // Numéro de contrat auto-généré
  merchantId    String
  templateId    String?        // Template de contrat utilisé
  title         String
  content       String         @db.Text // Contenu du contrat en format JSON ou HTML
  status        ContractStatus @default(DRAFT)
  type          ContractType   @default(STANDARD)
  
  // Données financières
  monthlyFee    Decimal?       @db.Decimal(10,2) // Frais mensuels
  commissionRate Decimal?      @db.Decimal(5,4)  // Taux de commission (ex: 0.15 = 15%)
  minimumVolume Int?           // Volume minimum requis
  
  // ===== EXTENSIONS MERCHANT =====
  // Spécificités pour les merchants
  merchantCategory String?      // Catégorie du merchant (alimentaire, mode, etc.)
  deliveryZone  String?        // Zone de livraison couverte
  maxDeliveryRadius Float?     // Rayon de livraison en km
  serviceLevelAgreement Json?  // SLA spécifique au merchant
  
  // Conditions commerciales spécifiques
  volumeDiscounts Json?        // Remises par volume { "1000": 0.05, "5000": 0.10 }
  paymentTerms   String?       // Conditions de paiement spécifiques
  exclusivityClause Boolean?   @default(false) // Clause d'exclusivité
  territoryRestrictions Json?  // Restrictions territoriales
  
  // Performance et qualité
  qualityMetrics Json?         // Métriques de qualité attendues
  performanceTargets Json?     // Objectifs de performance
  penaltyClause Json?          // Clauses de pénalité
  bonusStructure Json?         // Structure de bonus
  
  // Dates importantes
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  signedAt      DateTime?      // Date de signature par le merchant
  validatedAt   DateTime?      // Date de validation admin
  effectiveDate DateTime?      // Date d'entrée en vigueur
  expiresAt     DateTime?      // Date d'expiration
  
  // Documents et signatures
  fileUrl       String?        // PDF du contrat signé
  merchantSignature String?    // Signature électronique merchant
  adminSignature String?       // Signature électronique admin
  signedById    String?        // ID de l'admin qui a signé
  
  // Métadonnées
  metadata      Json?          // Données additionnelles du contrat
  terms         Json?          // Termes spécifiques en JSON
  notes         String?        // Notes internes
  
  // ===== NOUVEAUX CHAMPS MERCHANT =====
  // Historique et suivi
  negotiationHistory Json?     // Historique des négociations
  lastRenegotiationDate DateTime? // Dernière renégociation
  autoRenewal   Boolean?       @default(false) // Renouvellement automatique
  renewalNotice Int?           // Préavis de renouvellement (jours)
  
  // Assurance et garanties
  insuranceRequired Boolean?   @default(false) // Assurance requise
  insuranceAmount Decimal?     @db.Decimal(10,2) // Montant d'assurance
  securityDeposit Decimal?     @db.Decimal(10,2) // Dépôt de garantie
  
  // Relations avec le profil Merchant
  merchant      Merchant       @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  signedBy      User?          @relation("ContractSignedBy", fields: [signedById], references: [id])
  
  // Relations avec template et amendements
  template      ContractTemplate? @relation(fields: [templateId], references: [id])
  amendments    ContractAmendment[]
  negotiations  ContractNegotiation[]
  performances  ContractPerformance[]
  billingCycles BillingCycle[]

  @@index([merchantId])
  @@index([status])
  @@index([type])
  @@index([contractNumber])
  @@index([effectiveDate])
  @@index([merchantCategory]) // Nouvel index
  @@map("contracts")
}

/// Templates de contrats réutilisables
model ContractTemplate {
  id          String         @id @default(cuid())
  name        String         // Nom du template (ex: "Contrat Standard")
  description String?        // Description du template
  version     String         @default("1.0") // Version du template
  content     String         @db.Text // Contenu template en HTML/JSON
  isActive    Boolean        @default(true)
  
  // Configuration par défaut
  defaultType ContractType   @default(STANDARD)
  defaultMonthlyFee Decimal? @db.Decimal(10,2)
  defaultCommissionRate Decimal? @db.Decimal(5,4)
  defaultDuration Int?       // Durée par défaut en mois
  
  // ===== EXTENSIONS MERCHANT TEMPLATE =====
  // Spécificités par catégorie de merchant
  targetMerchantCategory String? // Catégorie cible du template
  requiredDocuments Json?     // Documents requis pour ce template
  minimumBusinessAge Int?     // Âge minimum de l'entreprise (mois)
  minimumTurnover Decimal?    @db.Decimal(12,2) // CA minimum requis
  
  // Conditions particulières
  defaultExclusivityClause Boolean? @default(false)
  defaultInsuranceRequired Boolean? @default(false)
  defaultSecurityDeposit Decimal? @db.Decimal(10,2)
  
  // Métadonnées
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  createdById String
  
  // Relations
  createdBy   User           @relation(fields: [createdById], references: [id])
  contracts   Contract[]
  
  @@index([isActive])
  @@index([defaultType])
  @@index([targetMerchantCategory]) // Nouvel index
  @@map("contract_templates")
}

/// Amendements aux contrats
model ContractAmendment {
  id          String         @id @default(cuid())
  contractId  String
  title       String         // Titre de l'amendement
  description String         // Description du changement
  content     String         @db.Text // Contenu de l'amendement
  status      ContractStatus @default(DRAFT)
  
  // ===== EXTENSIONS MERCHANT AMENDMENT =====
  // Type d'amendement spécifique
  amendmentType String?       // TYPE: "COMMISSION", "TERRITORY", "TERMS", "OTHER"
  previousValue Json?         // Valeur précédente
  newValue     Json?          // Nouvelle valeur
  businessJustification String? // Justification business
  impactAssessment Json?      // Évaluation d'impact
  
  // Approbation
  merchantApproved Boolean?   @default(false)
  adminApproved Boolean?      @default(false)
  merchantApprovedAt DateTime?
  adminApprovedAt DateTime?
  
  // Dates
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  signedAt    DateTime?
  effectiveDate DateTime?
  
  // Signature
  fileUrl     String?        // PDF de l'amendement signé
  signedById  String?
  
  // Relations
  contract    Contract       @relation(fields: [contractId], references: [id], onDelete: Cascade)
  signedBy    User?          @relation(fields: [signedById], references: [id])
  
  @@index([contractId])
  @@index([status])
  @@index([amendmentType]) // Nouvel index
  @@map("contract_amendments")
}

// ===== NOUVEAU MODÈLE: NÉGOCIATIONS =====
/// Historique des négociations de contrats
model ContractNegotiation {
  id          String         @id @default(cuid())
  contractId  String
  initiatedBy String         // USER_ID who initiated
  negotiationRound Int       // Numéro du tour de négociation
  
  // Détails de la négociation
  proposedChanges Json       // Changements proposés
  reason      String         // Raison de la négociation
  notes       String?        // Notes additionnelles
  
  // Statut
  status      String         // PENDING, ACCEPTED, REJECTED, COUNTER_PROPOSED
  
  // Réponse
  response    String?        // Réponse à la négociation
  respondedBy String?        // USER_ID who responded
  respondedAt DateTime?
  
  // Dates
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  
  // Relations
  contract    Contract       @relation(fields: [contractId], references: [id], onDelete: Cascade)
  initiator   User           @relation("NegotiationInitiator", fields: [initiatedBy], references: [id])
  responder   User?          @relation("NegotiationResponder", fields: [respondedBy], references: [id])
  
  @@index([contractId])
  @@index([status])
  @@map("contract_negotiations")
}

// ===== NOUVEAU MODÈLE: PERFORMANCE CONTRAT =====
/// Suivi de performance des contrats merchants
model ContractPerformance {
  id          String         @id @default(cuid())
  contractId  String
  
  // Période de mesure
  periodStart DateTime
  periodEnd   DateTime
  
  // Métriques de performance
  deliveryCount Int          @default(0)
  averageDeliveryTime Float? // En minutes
  customerSatisfaction Float? // Note moyenne sur 5
  
  // Métriques financières
  totalRevenue Decimal?      @db.Decimal(12,2)
  commissionPaid Decimal?    @db.Decimal(12,2)
  avgOrderValue Decimal?     @db.Decimal(10,2)
  
  // Conformité
  slaCompliance Float?       // % de respect du SLA
  qualityScore Float?        // Score qualité global
  
  // Objectifs
  targetsMet   Json?         // Objectifs atteints
  bonusEarned  Decimal?      @db.Decimal(10,2)
  penaltiesApplied Decimal? @db.Decimal(10,2)
  
  // Métadonnées
  calculatedAt DateTime      @default(now())
  notes       String?
  
  // Relations
  contract    Contract       @relation(fields: [contractId], references: [id], onDelete: Cascade)
  
  @@index([contractId])
  @@index([periodStart, periodEnd])
  @@map("contract_performance")
} 
// ===== MODÈLES DE DOCUMENTS =====
// Ce fichier contient les modèles pour la gestion des documents téléversés par les utilisateurs.

/// Document téléversé par un utilisateur pour vérification
model Document {
  id                  String                @id @default(cuid())
  type                DocumentType
  userId              String
  userRole            UserRole              @default(CLIENT)
  filename            String
  fileUrl             String
  mimeType            String
  fileSize            Int
  uploadedAt          DateTime              @default(now())
  expiryDate          DateTime?
  notes               String?
  isVerified          Boolean               @default(false)
  verificationStatus  VerificationStatus    @default(PENDING)
  rejectionReason     String?
  reviewerId          String?
  
  // Relations avec l'utilisateur et le réviseur
  reviewer            User?                 @relation("DocumentReviewer", fields: [reviewerId], references: [id])
  user                User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  verificationHistory VerificationHistory[]
  verifications       Verification[]

  @@index([userId])
  @@index([type])
  @@index([verificationStatus])
  @@index([userRole])
  @@map("documents")
} 
// ===== MODÈLES DE NOTIFICATIONS =====
// Ce fichier contient le modèle pour les notifications envoyées aux utilisateurs.

/// Notification envoyée à un utilisateur
model Notification {
  id        String    @id @default(cuid())
  userId    String
  title     String
  message   String
  type      String
  link      String?
  data      String?
  read      Boolean   @default(false)
  readAt    DateTime?
  createdAt DateTime  @default(now())
  
  // Relation avec le modèle User
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@map("notifications")
} 
// ===== MODÈLES KPIs ET MONITORING PLATEFORME =====
// Ce fichier contient les modèles pour le dashboard admin et le monitoring des 6 entrepôts selon le cahier des charges

/// KPI temps réel de la plateforme
model PlatformKpi {
  id            String    @id @default(cuid())
  kpiType       KpiType   // Type de KPI
  
  // Valeurs du KPI
  currentValue  Decimal   @db.Decimal(15,2) // Valeur actuelle
  previousValue Decimal?  @db.Decimal(15,2) // Valeur précédente pour comparaison
  targetValue   Decimal?  @db.Decimal(15,2) // Objectif cible
  
  // Période de mesure
  periodStart   DateTime  // Début de la période
  periodEnd     DateTime  // Fin de la période
  periodType    String    // Type de période: HOUR, DAY, WEEK, MONTH, YEAR
  
  // Métadonnées
  unit          String?   // Unité de mesure (€, %, nb, etc.)
  description   String?   // Description du KPI
  formula       String?   // Formule de calcul
  
  // Alertes
  alertThreshold Decimal? @db.Decimal(15,2) // Seuil d'alerte
  isAlert       Boolean   @default(false) // En alerte actuellement
  alertMessage  String?   // Message d'alerte
  
  // Évolution
  growthRate    Decimal?  @db.Decimal(8,4) // Taux de croissance (%)
  trend         String?   // Tendance: UP, DOWN, STABLE
  
  // Détails par site
  siteBreakdown Json?     // Répartition par site (JSON)
  
  // Métadonnées
  calculatedAt  DateTime  @default(now())
  createdAt     DateTime  @default(now())
  
  // Historique des valeurs
  history       KpiHistory[]

  @@index([kpiType, periodType])
  @@index([periodStart, periodEnd])
  @@index([isAlert])
  @@map("platform_kpis")
}

/// Historique des valeurs de KPIs
model KpiHistory {
  id        String      @id @default(cuid())
  kpiId     String
  value     Decimal     @db.Decimal(15,2)
  timestamp DateTime    @default(now())
  
  // Relations
  kpi       PlatformKpi @relation(fields: [kpiId], references: [id], onDelete: Cascade)

  @@index([kpiId, timestamp])
  @@map("kpi_history")
}

/// Statistiques multi-sites (6 entrepôts EcoDeli)
model MultiSiteStats {
  id            String        @id @default(cuid())
  siteType      SiteStatsType // Type de site/entrepôt
  
  // Informations du site
  siteName      String        // Nom du site
  siteAddress   String        // Adresse complète
  siteLat       Float         // Latitude
  siteLng       Float         // Longitude
  
  // Période de statistique
  periodStart   DateTime      // Début de la période
  periodEnd     DateTime      // Fin de la période
  periodType    String        // HOUR, DAY, WEEK, MONTH
  
  // Métriques d'activité
  deliveryCount         Int             @default(0) // Nombre de livraisons
  activeDeliverers      Int             @default(0) // Livreurs actifs
  storageOccupancy      Float           @default(0) // Taux d'occupation stockage (%)
  averageDeliveryTime   Float?          // Temps moyen de livraison (min)
  
  // Métriques financières
  revenue              Decimal          @db.Decimal(12,2) @default(0) // Chiffre d'affaires
  commissions          Decimal          @db.Decimal(10,2) @default(0) // Commissions perçues
  averageOrderValue    Decimal?         @db.Decimal(8,2) // Panier moyen
  
  // Métriques qualité
  customerSatisfaction Float?           // Satisfaction client (note/5)
  onTimeDeliveryRate   Float            @default(0) // Taux de livraison à l'heure (%)
  errorRate            Float            @default(0) // Taux d'erreur (%)
  
  // Métriques utilisateurs
  newCustomers         Int              @default(0) // Nouveaux clients
  activeCustomers      Int              @default(0) // Clients actifs
  churnRate            Float?           // Taux de désabonnement (%)
  
  // Capacités et ressources
  maxStorageCapacity   Int              // Capacité stockage maximale
  currentStorageUsage  Int              @default(0) // Usage actuel
  availableDeliverers  Int              @default(0) // Livreurs disponibles
  
  // Alertes et problèmes
  activeAlerts         Int              @default(0) // Alertes actives
  criticalIssues       Int              @default(0) // Problèmes critiques
  maintenanceMode      Boolean          @default(false) // Mode maintenance
  
  // Comparaison avec autres sites
  rankAmongSites       Int?             // Classement parmi les sites
  performanceIndex     Float?           // Indice de performance (0-100)
  
  // Métadonnées
  calculatedAt         DateTime         @default(now())
  createdAt            DateTime         @default(now())

  @@index([siteType])
  @@index([periodStart, periodEnd])
  @@index([rankAmongSites])
  @@map("multi_site_stats")
}

/// Prévisions financières
model FinancialForecast {
  id              String        @id @default(cuid())
  forecastType    ForecastType  // Type de prévision
  
  // Période de prévision
  periodStart     DateTime      // Début de la période prévue
  periodEnd       DateTime      // Fin de la période prévue
  
  // Métriques prévisionnelles
  projectedRevenue      Decimal     @db.Decimal(15,2) // CA projeté
  projectedCosts        Decimal     @db.Decimal(15,2) // Coûts projetés
  projectedProfit       Decimal     @db.Decimal(15,2) // Profit projeté
  projectedGrowthRate   Decimal     @db.Decimal(6,4)  // Taux de croissance (%)
  
  // Prévisions d'activité
  projectedDeliveries   Int         // Livraisons prévues
  projectedNewUsers     Int         // Nouveaux utilisateurs prévus
  projectedChurnRate    Decimal     @db.Decimal(6,4) // Taux de désabonnement prévu
  
  // Scénarios
  scenarioType          String      // OPTIMISTIC, REALISTIC, PESSIMISTIC
  confidenceLevel       Float       // Niveau de confiance (0-100%)
  
  // Hypothèses
  assumptions           Json        // Hypothèses de calcul (JSON)
  riskFactors           Json?       // Facteurs de risque identifiés
  
  // Comparaison avec réalité
  actualRevenue         Decimal?    @db.Decimal(15,2) // CA réel (après coup)
  actualCosts           Decimal?    @db.Decimal(15,2) // Coûts réels
  actualProfit          Decimal?    @db.Decimal(15,2) // Profit réel
  accuracyScore         Float?      // Score de précision (%)
  
  // Mise à jour
  lastRevisedAt         DateTime?   // Dernière révision
  revisionNotes         String?     // Notes de révision
  
  // Créateur
  createdBy             String      // Admin qui a créé la prévision
  createdAt             DateTime    @default(now())
  updatedAt             DateTime    @updatedAt
  
  // Relations
  creator               User        @relation("ForecastCreator", fields: [createdBy], references: [id])

  @@index([forecastType])
  @@index([periodStart, periodEnd])
  @@index([scenarioType])
  @@map("financial_forecasts")
}

/// Monitoring temps réel de la plateforme
model PlatformMonitoring {
  id                String    @id @default(cuid())
  
  // Métriques système
  systemStatus      String    @default("HEALTHY") // HEALTHY, WARNING, CRITICAL, DOWN
  uptime            Float     // Uptime en %
  responseTime      Float     // Temps de réponse moyen (ms)
  errorRate         Float     // Taux d'erreur (%)
  
  // Métriques base de données
  dbConnectionCount Int       // Connexions DB actives
  dbQueryTime       Float     // Temps de requête moyen (ms)
  dbStorageUsage    Float     // Usage stockage DB (%)
  
  // Métriques API
  apiRequestCount   Int       // Requêtes API/minute
  apiErrorCount     Int       // Erreurs API/minute
  apiLatency        Float     // Latence API moyenne (ms)
  
  // Métriques utilisateurs
  activeUsers       Int       // Utilisateurs actifs en temps réel
  concurrentSessions Int      // Sessions concurrentes
  newRegistrations  Int       // Nouvelles inscriptions/heure
  
  // Métriques livraisons
  ongoingDeliveries Int       // Livraisons en cours
  pendingDeliveries Int       // Livraisons en attente
  completedToday    Int       // Livraisons terminées aujourd'hui
  
  // Métriques financières temps réel
  revenueToday      Decimal   @db.Decimal(10,2) // CA du jour
  transactionsCount Int       // Transactions du jour
  averageBasket     Decimal   @db.Decimal(8,2)  // Panier moyen
  
  // Alertes actives
  activeAlerts      Json?     // Alertes en cours (array)
  criticalAlerts    Int       @default(0) // Nombre d'alertes critiques
  warningAlerts     Int       @default(0) // Nombre d'alertes warning
  
  // Métadonnées
  timestamp         DateTime  @default(now())
  
  @@index([systemStatus])
  @@index([timestamp])
  @@map("platform_monitoring")
}

/// Configuration d'alertes
model AlertConfiguration {
  id              String    @id @default(cuid())
  alertType       String    // Type d'alerte
  
  // Conditions de déclenchement
  metricName      String    // Nom de la métrique surveillée
  threshold       Decimal   @db.Decimal(15,2) // Seuil de déclenchement
  operator        String    // Opérateur: GT, LT, EQ, etc.
  duration        Int       // Durée avant déclenchement (minutes)
  
  // Paramètres de l'alerte
  severity        String    // CRITICAL, WARNING, INFO
  message         String    // Message d'alerte
  isActive        Boolean   @default(true)
  
  // Notifications
  emailNotification Boolean @default(true)
  smsNotification   Boolean @default(false)
  pushNotification  Boolean @default(true)
  webhookUrl        String? // Webhook à appeler
  
  // Destinataires
  notifyRoles     String[]  // Rôles à notifier
  notifyUsers     String[]  // Utilisateurs spécifiques à notifier
  
  // Historique
  lastTriggered   DateTime? // Dernière activation
  triggerCount    Int       @default(0) // Nombre d'activations
  
  // Métadonnées
  createdBy       String    // Admin créateur
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  creator         User      @relation("AlertCreator", fields: [createdBy], references: [id])
  
  // Historique des déclenchements
  triggers        AlertTrigger[]

  @@index([isActive])
  @@index([severity])
  @@map("alert_configurations")
}

/// Historique des déclenchements d'alertes
model AlertTrigger {
  id            String              @id @default(cuid())
  alertId       String
  
  // Informations du déclenchement
  triggerValue  Decimal             @db.Decimal(15,2) // Valeur qui a déclenché
  message       String              // Message personnalisé
  severity      String              // Sévérité au moment du déclenchement
  
  // Résolution
  isResolved    Boolean             @default(false)
  resolvedAt    DateTime?
  resolvedBy    String?             // Admin qui a résolu
  resolutionNotes String?           // Notes de résolution
  
  // Métadonnées
  triggeredAt   DateTime            @default(now())
  
  // Relations
  alert         AlertConfiguration  @relation(fields: [alertId], references: [id], onDelete: Cascade)
  resolver      User?               @relation("AlertResolver", fields: [resolvedBy], references: [id])

  @@index([alertId])
  @@index([triggeredAt])
  @@index([isResolved])
  @@map("alert_triggers")
}
// ===== MODÈLES DE VERIFICATION =====
// Ce fichier contient les modèles pour la vérification des documents utilisateurs.

/// Demande de vérification d'un document
model Verification {
  id              String             @id @default(cuid())
  status          VerificationStatus @default(PENDING)
  requestedAt     DateTime           @default(now())
  verifiedAt      DateTime?
  documentId      String
  submitterId     String
  verifierId      String?
  notes           String?
  rejectionReason String?
  
  // Relations
  document        Document           @relation(fields: [documentId], references: [id], onDelete: Cascade)
  submitter       User               @relation("SubmitterRelation", fields: [submitterId], references: [id])
  verifier        User?              @relation("VerifierRelation", fields: [verifierId], references: [id])

  @@index([documentId])
  @@index([submitterId])
  @@index([verifierId])
  @@index([status])
  @@map("verifications")
}

/// Historique des vérifications effectuées
model VerificationHistory {
  id            String             @id @default(cuid())
  status        VerificationStatus
  comment       String?
  createdAt     DateTime           @default(now())
  documentId    String?
  userId        String
  verifiedById  String
  reason        String?
  internalNotes String?
  
  // Relations
  document      Document?          @relation(fields: [documentId], references: [id])
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  verifiedBy    User               @relation("VerifierRelation", fields: [verifiedById], references: [id])

  @@index([documentId])
  @@index([userId])
  @@index([verifiedById])
  @@map("verification_history")
}

/// Modèle spécifique pour la vérification des comptes commerçants
model MerchantVerification {
  id                 String             @id @default(cuid())
  merchantId         String             @unique
  status             VerificationStatus @default(PENDING)
  requestedAt        DateTime           @default(now())
  verifiedAt         DateTime?
  verifierId         String?
  notes              String?
  rejectionReason    String?
  businessDocuments  String[]           // IDs des documents d'entreprise soumis
  identityDocuments  String[]           // IDs des documents d'identité soumis
  addressDocuments   String[]           // IDs des documents de preuve d'adresse
  businessRegistered Boolean            @default(false)    // Si l'entreprise est officiellement enregistrée
  taxCompliant       Boolean            @default(false)    // Si l'entreprise est à jour fiscalement
  
  // Relations
  merchant           Merchant           @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  verifier           User?              @relation("MerchantVerifier", fields: [verifierId], references: [id])

  @@index([merchantId])
  @@index([verifierId])
  @@index([status])
  @@map("merchant_verifications")
}

/// Modèle spécifique pour la vérification des comptes prestataires
model ProviderVerification {
  id                 String             @id @default(cuid())
  providerId         String             @unique
  status             VerificationStatus @default(PENDING)
  requestedAt        DateTime           @default(now())
  verifiedAt         DateTime?
  verifierId         String?
  notes              String?
  rejectionReason    String?
  identityDocuments  String[]           // IDs des documents d'identité soumis
  qualificationDocs  String[]           // IDs des documents de qualification professionnelle
  insuranceDocs      String[]           // IDs des documents d'assurance
  addressDocuments   String[]           // IDs des documents de preuve d'adresse
  qualificationsVerified Boolean        @default(false)    // Si les qualifications ont été vérifiées
  insuranceValid     Boolean            @default(false)    // Si l'assurance est valide
  
  // Relations
  provider           Provider           @relation(fields: [providerId], references: [id], onDelete: Cascade)
  verifier           User?              @relation("ProviderVerifier", fields: [verifierId], references: [id])

  @@index([providerId])
  @@index([verifierId])
  @@index([status])
  @@map("provider_verifications")
} 

// ----- DOMAINE: MESSAGES -----

// ===== MODÈLES DE MESSAGERIE =====
// Ce fichier contient les modèles pour les conversations et messages entre utilisateurs.

/// Conversation entre deux utilisateurs
model Conversation {
  id          String    @id @default(cuid())
  title       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Participants à la conversation
  participantIds String[]
  
  // Métadonnées
  isArchived  Boolean   @default(false)
  lastMessageAt DateTime?
  status      String    @default("ACTIVE") // ACTIVE, PENDING, ARCHIVED
  
  // Relations
  messages    Message[]

  @@map("conversations")
}

/// Message dans une conversation
model Message {
  id              String    @id @default(cuid())
  conversationId  String
  senderId        String
  content         String
  createdAt       DateTime  @default(now())
  
  // Statut de lecture
  status          String    @default("UNREAD") // READ, UNREAD, DELETED
  readAt          DateTime?
  
  // Métadonnées
  attachments     Json?
  replyToId       String?
  
  // Relations
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender          User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
  @@index([status])
  @@map("messages")
} 
