# =============================================================================
# DOCKER COMPOSE POUR ECODELI - ENVIRONNEMENT DE PRODUCTION
# =============================================================================

version: '3.8'

services:
  # =============================================================================
  # APPLICATION WEB NEXT.JS
  # =============================================================================
  ecodeli-web:
    build:
      context: .
      dockerfile: docker/web/Dockerfile
      target: production
    container_name: ecodeli-web-prod
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - NEXTAUTH_URL=${NEXTAUTH_URL}
      - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
      - STRIPE_PUBLIC_KEY=${STRIPE_PUBLIC_KEY}
      - STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}
      - STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET}
      - ONESIGNAL_APP_ID=${ONESIGNAL_APP_ID}
      - ONESIGNAL_API_KEY=${ONESIGNAL_API_KEY}
      - MAILGUN_API_KEY=${MAILGUN_API_KEY}
      - MAILGUN_DOMAIN=${MAILGUN_DOMAIN}
      - CLOUDINARY_CLOUD_NAME=${CLOUDINARY_CLOUD_NAME}
      - CLOUDINARY_API_KEY=${CLOUDINARY_API_KEY}
      - CLOUDINARY_API_SECRET=${CLOUDINARY_API_SECRET}
    volumes:
      - uploads_data:/app/uploads
    depends_on:
      - ecodeli-db
    networks:
      - ecodeli_network
    restart: always
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.ecodeli-web-prod.rule=Host(`ecodeli.me`, `www.ecodeli.me`)"
      - "traefik.http.routers.ecodeli-web-prod.tls=true"
      - "traefik.http.routers.ecodeli-web-prod.tls.certresolver=letsencrypt"

  # =============================================================================
  # BASE DE DONNÉES POSTGRESQL
  # =============================================================================
  ecodeli-db:
    build:
      context: docker/database
      dockerfile: Dockerfile
    container_name: ecodeli-db-prod
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - PGDATA=/var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data_prod:/var/lib/postgresql/data
      - postgres_backups_prod:/var/lib/postgresql/backups
      - ./docker/database/init:/docker-entrypoint-initdb.d:ro
    networks:
      - ecodeli_network
    restart: always
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '1.0'
          memory: 1G
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "${POSTGRES_USER}", "-d", "${POSTGRES_DB}"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    command: >
      postgres 
      -c max_connections=200
      -c shared_buffers=512MB
      -c effective_cache_size=2GB
      -c work_mem=8MB
      -c maintenance_work_mem=128MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=32MB
      -c max_wal_size=2GB
      -c min_wal_size=160MB
      -c log_min_duration_statement=1000
      -c log_checkpoints=on
      -c log_connections=on
      -c log_disconnections=on

  # =============================================================================
  # REVERSE PROXY NGINX
  # =============================================================================
  ecodeli-nginx:
    build:
      context: docker/nginx
      dockerfile: Dockerfile
    container_name: ecodeli-nginx-prod
    ports:
      - "80:80"
      - "443:443"
    environment:
      - NGINX_HOST=ecodeli.me
      - NGINX_PORT=80
    volumes:
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./docker/nginx/sites:/etc/nginx/sites-available:ro
      - nginx_logs_prod:/var/log/nginx
      - certbot_www_prod:/var/www/certbot
      - letsencrypt_certs:/etc/letsencrypt
    depends_on:
      - ecodeli-web
    networks:
      - ecodeli_network
    restart: always
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  # =============================================================================
  # CERTBOT POUR SSL
  # =============================================================================
  certbot:
    image: certbot/certbot
    container_name: ecodeli-certbot
    volumes:
      - certbot_www_prod:/var/www/certbot
      - letsencrypt_certs:/etc/letsencrypt
    command: >
      certonly --webroot --webroot-path=/var/www/certbot 
      --email admin@ecodeli.me 
      --agree-tos --no-eff-email 
      -d ecodeli.me -d www.ecodeli.me
    depends_on:
      - ecodeli-nginx
    networks:
      - ecodeli_network

  # =============================================================================
  # BACKUP AUTOMATIQUE
  # =============================================================================
  ecodeli-backup:
    build:
      context: docker/backup
      dockerfile: Dockerfile
    container_name: ecodeli-backup
    environment:
      - POSTGRES_HOST=ecodeli-db
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - BACKUP_SCHEDULE=0 2 * * *
      - BACKUP_RETENTION_DAYS=30
    volumes:
      - postgres_backups_prod:/backups/database
      - uploads_data:/backups/uploads:ro
      - backup_archives:/backups/archives
    depends_on:
      - ecodeli-db
    networks:
      - ecodeli_network
    restart: always

  # =============================================================================
  # MONITORING ET HEALTH CHECKS
  # =============================================================================
  ecodeli-monitoring:
    build:
      context: docker/monitoring
      dockerfile: Dockerfile
    container_name: ecodeli-monitoring-prod
    environment:
      - SERVICES_TO_MONITOR=ecodeli-web,ecodeli-db,ecodeli-nginx
      - ALERT_EMAIL=${ALERT_EMAIL}
      - SLACK_WEBHOOK=${SLACK_WEBHOOK}
    volumes:
      - monitoring_data_prod:/app/data
      - ./docker/monitoring/scripts:/app/scripts:ro
    depends_on:
      - ecodeli-web
      - ecodeli-db
      - ecodeli-nginx
    networks:
      - ecodeli_network
    restart: always
    deploy:
      resources:
        limits:
          cpus: '0.25'
          memory: 256M

# =============================================================================
# RÉSEAUX
# =============================================================================
networks:
  ecodeli_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.21.0.0/16
    labels:
      - "me.ecodeli.network=production"

# =============================================================================
# VOLUMES PERSISTANTS
# =============================================================================
volumes:
  postgres_data_prod:
    driver: local
    labels:
      - "me.ecodeli.volume=database-prod"
  postgres_backups_prod:
    driver: local
    labels:
      - "me.ecodeli.volume=backups-prod"
  nginx_logs_prod:
    driver: local
    labels:
      - "me.ecodeli.volume=logs-prod"
  certbot_www_prod:
    driver: local
    labels:
      - "me.ecodeli.volume=ssl-prod"
  letsencrypt_certs:
    driver: local
    labels:
      - "me.ecodeli.volume=ssl-certs"
  uploads_data:
    driver: local
    labels:
      - "me.ecodeli.volume=uploads"
  backup_archives:
    driver: local
    labels:
      - "me.ecodeli.volume=backup-archives"
  monitoring_data_prod:
    driver: local
    labels:
      - "me.ecodeli.volume=monitoring-prod"