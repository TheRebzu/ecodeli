import { NextRequest, NextResponse } from "next/server";
import { getUserFromSession } from "@/lib/auth/utils";
import { db } from "@/lib/db";
import { z } from "zod";
import Stripe from "stripe";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2024-06-20",
});

const paymentSchema = z.object({
  paymentMethod: z.enum(["CARD", "WALLET", "BANK_TRANSFER"]),
  amount: z.number().positive(),
  currency: z.string().default("EUR"),
});

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    console.log(
      "üîç [POST /api/client/applications/[id]/pay] Paiement service par client",
    );

    const user = await getUserFromSession(request);
    if (!user || user.role !== "CLIENT") {
      console.log("‚ùå Utilisateur non authentifi√© ou non client");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    console.log("‚úÖ Client authentifi√©:", user.id, user.role);

    // V√©rifier que le profil client existe
    if (!user.client) {
      console.log("‚ùå Profil client introuvable");
      return NextResponse.json(
        { error: "Profil client introuvable" },
        { status: 400 },
      );
    }

    const { id: applicationId } = await params;
    const body = await request.json();

    try {
      const validatedData = paymentSchema.parse(body);
      console.log("‚úÖ Donn√©es de paiement valid√©es:", validatedData);

      // V√©rifier que la candidature existe et a √©t√© accept√©e
      const application = await db.serviceApplication.findUnique({
        where: { id: applicationId },
        include: {
          announcement: {
            include: {
              author: true,
              ServiceAnnouncement: true,
            },
          },
          provider: {
            include: {
              profile: true,
            },
          },
        },
      });

      if (!application) {
        console.log("‚ùå Candidature non trouv√©e");
        return NextResponse.json(
          { error: "Candidature non trouv√©e" },
          { status: 404 },
        );
      }

      // V√©rifier que le client est bien l'auteur de la demande de service
      if (application.announcement.authorId !== user.id) {
        console.log("‚ùå Acc√®s non autoris√© √† cette candidature");
        return NextResponse.json(
          { error: "Acc√®s non autoris√©" },
          { status: 403 },
        );
      }

      // V√©rifier que la candidature a √©t√© accept√©e ou est en attente de paiement (retry)
      console.log("üîç Statut actuel de la candidature:", application.status);
      if (!["ACCEPTED", "PAYMENT_PENDING"].includes(application.status)) {
        console.log("‚ùå Candidature non accept√©e - statut:", application.status);
        return NextResponse.json(
          {
            error: `Cette candidature n'a pas √©t√© accept√©e (statut: ${application.status})`,
          },
          { status: 400 },
        );
      }

      // V√©rifier que le service n'a pas d√©j√† √©t√© pay√© avec succ√®s
      const existingPayment = await db.payment.findFirst({
        where: {
          userId: user.id,
          type: "SERVICE",
          metadata: {
            path: ["applicationId"],
            equals: applicationId,
          },
        },
      });

      if (existingPayment && existingPayment.status === "COMPLETED") {
        console.log("‚ùå Service d√©j√† pay√© avec succ√®s");
        return NextResponse.json(
          {
            error: "Ce service a d√©j√† √©t√© pay√©",
          },
          { status: 400 },
        );
      }

      // Si un paiement existe mais n'est pas completed, le supprimer pour permettre un retry propre
      if (existingPayment && existingPayment.status !== "COMPLETED") {
        console.log("üîç Suppression du paiement existant non completed pour retry propre");
        await db.payment.delete({
          where: { id: existingPayment.id },
        });
      }

      console.log("üîç Cr√©ation du paiement Stripe...");

      // Cr√©er le PaymentIntent Stripe
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(validatedData.amount * 100), // Stripe utilise les centimes
        currency: validatedData.currency.toLowerCase(),
        automatic_payment_methods: {
          enabled: true,
        },
        metadata: {
          applicationId: applicationId,
          announcementId: application.announcementId,
          providerId: application.providerId,
          proposedPrice: application.proposedPrice?.toString() || "0",
          estimatedDuration: application.estimatedDuration?.toString() || "0",
          type: "service_payment",
        },
        description: `Paiement service - ${application.announcement.title}`,
        receipt_email: user.email,
      });

      // Cr√©er l'enregistrement de paiement en base
      const payment = await db.payment.create({
        data: {
          userId: user.id,
          amount: validatedData.amount,
          currency: validatedData.currency,
          status: "PENDING",
          type: "SERVICE",
          paymentMethod: validatedData.paymentMethod,
          stripePaymentId: paymentIntent.id,
          metadata: {
            applicationId: applicationId,
            announcementId: application.announcementId,
            providerId: application.providerId,
            proposedPrice: application.proposedPrice,
            estimatedDuration: application.estimatedDuration,
            stripePaymentIntentId: paymentIntent.id,
          },
        },
      });

      console.log("‚úÖ PaymentIntent Stripe cr√©√©:", paymentIntent.id);
      console.log("‚úÖ Paiement en base cr√©√©:", payment.id);

      // Mettre √† jour le statut de la candidature (en attente de confirmation Stripe)
      await db.serviceApplication.update({
        where: { id: applicationId },
        data: {
          status: "PAYMENT_PENDING",
        },
      });

      console.log("‚úÖ Candidature mise √† jour: PAYMENT_PENDING");

      // Cr√©er une notification pour le prestataire
      await db.notification.create({
        data: {
          userId: application.provider.id,
          title: "Paiement en cours",
          message: `Le client a initi√© le paiement pour le service "${application.announcement.title}".`,
          type: "SERVICE_PAYMENT_PENDING",
          data: {
            applicationId: applicationId,
            announcementId: application.announcementId,
            paymentId: payment.id,
            amount: validatedData.amount,
          },
        },
      });

      console.log("‚úÖ Notification cr√©√©e pour le prestataire");

      // R√©cup√©rer le Provider correspondant au User
      const providerProfile = await db.provider.findUnique({
        where: { userId: application.providerId }
      });

      if (!providerProfile) {
        console.error("‚ùå Aucun profil prestataire trouv√© pour l'utilisateur:", application.providerId);
        return NextResponse.json(
          { 
            success: false, 
            error: "PROVIDER_NOT_FOUND",
            message: "Profil prestataire introuvable" 
          },
          { status: 404 }
        );
      }

      console.log("‚úÖ Profil prestataire trouv√©:", providerProfile.id);

      // Cr√©er ou r√©cup√©rer un service bas√© sur l'annonce
      let service = await db.service.findFirst({
        where: {
          providerId: providerProfile.id,
          name: application.announcement.title,
          type: application.announcement.ServiceAnnouncement?.serviceType || "HOME_SERVICE"
        }
      });

      if (!service) {
        // Cr√©er un service temporaire bas√© sur l'annonce
        service = await db.service.create({
          data: {
            providerId: providerProfile.id,
            name: application.announcement.title,
            description: application.announcement.description || "Service bas√© sur une demande client",
            type: application.announcement.ServiceAnnouncement?.serviceType || "HOME_SERVICE",
            basePrice: validatedData.amount,
            priceUnit: "FLAT",
            duration: application.estimatedDuration || 60,
            isActive: true,
          }
        });
        console.log("‚úÖ Service temporaire cr√©√©:", service.id);
      } else {
        console.log("‚úÖ Service existant trouv√©:", service.id);
      }

      // Cr√©er d'abord un booking apr√®s validation du paiement
      const booking = await db.booking.create({
        data: {
          clientId: user.client.id,
          providerId: providerProfile.id, // Utiliser l'ID du Provider, pas du User
          serviceId: service.id, // Utiliser l'ID du Service cr√©√© ou trouv√©
          status: "CONFIRMED",
          scheduledDate: new Date(), // √Ä adapter selon les besoins
          scheduledTime: "09:00", // Heure par d√©faut, √† adapter
          duration: application.estimatedDuration || 60,
          address: {
            address: "√Ä d√©finir",
            city: "√Ä d√©finir", 
            postalCode: "00000",
            lat: 0,
            lng: 0
          },
          totalPrice: validatedData.amount,
          notes: `R√©servation automatique suite au paiement de la candidature ${applicationId}`,
        },
      });

      console.log("‚úÖ Booking cr√©√©:", booking.id);

      // Trouver le provider correspondant au user de l'application
      const provider = await db.provider.findUnique({
        where: { userId: application.providerId },
      });

      if (!provider) {
        console.log("‚ùå Provider non trouv√© pour userId:", application.providerId);
        throw new Error(`Provider non trouv√© pour l'utilisateur ${application.providerId}`);
      }

      console.log("‚úÖ Provider trouv√©:", provider.id);

      // Cr√©er l'intervention li√©e au booking
      const intervention = await db.intervention.create({
        data: {
          bookingId: booking.id,
          providerId: provider.id,
          isCompleted: false,
        },
      });

      console.log("‚úÖ Intervention cr√©√©e (li√©e au booking):", intervention.id);

      return NextResponse.json({
        success: true,
        payment: {
          id: payment.id,
          amount: payment.amount,
          currency: payment.currency,
          status: payment.status,
        },
        stripe: {
          paymentIntentId: paymentIntent.id,
          clientSecret: paymentIntent.client_secret,
        },
        booking: {
          id: booking.id,
          status: booking.status,
          scheduledDate: booking.scheduledDate,
        },
        intervention: {
          id: intervention.id,
          isCompleted: intervention.isCompleted,
        },
      });
    } catch (validationError) {
      console.error("‚ùå Erreur de validation:", validationError);
      if (validationError instanceof z.ZodError) {
        return NextResponse.json(
          { error: "Donn√©es invalides", details: validationError.errors },
          { status: 400 },
        );
      }
      throw validationError;
    }
  } catch (error) {
    console.error("‚ùå Erreur g√©n√©rale:", error);
    return NextResponse.json(
      { error: "Erreur interne du serveur" },
      { status: 500 },
    );
  }
}
