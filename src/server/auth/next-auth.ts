import { PrismaAdapter } from '@auth/prisma-adapter';\nimport { UserRole } from '@prisma/client';\nimport { type NextAuthOptions } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { db } from '../db';\nimport { compare } from 'bcryptjs';\n\nexport const authOptions: NextAuthOptions = {\n  adapter: PrismaAdapter(db),\n  session: {\n    strategy: 'jwt',\n    maxAge: 30 * 24 * 60 * 60, // 30 jours\n  },\n  pages: {\n    signIn: '/login',\n    error: '/login',\n    newUser: '/register',\n  },\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n        \n        const user = await db.user.findUnique({\n          where: { email: credentials.email },\n          include: {\n            client: true,\n            deliverer: true,\n            merchant: true,\n            provider: true,\n            admin: true,\n          },\n        });\n        \n        if (!user || !user.passwordHash || !await compare(credentials.password, user.passwordHash)) {\n          return null;\n        }\n        \n        // VÃ©rification email et compte\n        if (user.role !== UserRole.ADMIN && !user.emailVerified) {\n          throw new Error('EMAIL_NOT_VERIFIED');\n        }\n        \n        if (\n          (user.role === UserRole.DELIVERER && user.deliverer && !user.deliverer.isVerified) ||\n          (user.role === UserRole.PROVIDER && user.provider && !user.provider.isVerified)\n        ) {\n          throw new Error('ACCOUNT_NOT_VERIFIED');\n        }\n        \n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          role: user.role,\n          profileId: \n            user.client?.id || \n            user.deliverer?.id || \n            user.merchant?.id || \n            user.provider?.id ||\n            user.admin?.id\n        };\n      },\n    }),\n  ],\n  callbacks: {\n    jwt: async ({ token, user }) => {\n      if (user) {\n        token.id = user.id;\n        token.role = user.role;\n        token.profileId = user.profileId;\n      }\n      return token;\n    },\n    session: ({ session, token }) => {\n      if (token && session.user) {\n        session.user.id = token.id as string;\n        session.user.role = token.role as UserRole;\n        session.user.profileId = token.profileId as string;\n      }\n      return session;\n    },\n  },\n};