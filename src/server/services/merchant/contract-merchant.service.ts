import { db } from '@/server/db';
import { TRPCError } from '@trpc/server';
import { ContractStatus, ContractType } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
import { addDays, addMonths, isBefore, format } from 'date-fns';
import { contractService, ContractService } from '@/server/services/shared/contract.service';

export interface MerchantContractCreateInput {
  merchantId: string;
  templateId?: string;
  title: string;
  content: string;
  type: ContractType;

  // Données financières
  monthlyFee?: number;
  commissionRate?: number;
  minimumVolume?: number;

  // Spécificités merchant
  merchantCategory?: string;
  deliveryZone?: string;
  maxDeliveryRadius?: number;
  serviceLevelAgreement?: Record<string, any>;

  // Conditions commerciales
  volumeDiscounts?: Record<string, number>;
  paymentTerms?: string;
  exclusivityClause?: boolean;
  territoryRestrictions?: Record<string, any>;

  // Performance
  qualityMetrics?: Record<string, any>;
  performanceTargets?: Record<string, any>;
  penaltyClause?: Record<string, any>;
  bonusStructure?: Record<string, any>;

  // Assurance
  insuranceRequired?: boolean;
  insuranceAmount?: number;
  securityDeposit?: number;

  // Renouvellement
  autoRenewal?: boolean;
  renewalNotice?: number;

  // Dates
  effectiveDate?: Date;
  expiresAt?: Date;
  terms?: Record<string, any>;
  notes?: string;
}

export interface ContractNegotiationInput {
  contractId: string;
  initiatedBy: string;
  proposedChanges: Record<string, any>;
  reason: string;
  notes?: string;
}

/**
 * Service spécialisé pour les contrats merchants
 * Étend le ContractService de base avec des fonctionnalités spécifiques
 */
export class MerchantContractService extends ContractService {
  /**
   * Crée un contrat merchant avec spécificités
   */
  async createMerchantContract(data: MerchantContractCreateInput) {
    // Validation des données merchant
    await this.validateMerchantData(data.merchantId);

    // Vérifier les prérequis pour le type de contrat
    await this.validateContractPrerequisites(data);

    // Créer le contrat avec les extensions merchant
    const contractData = {
      ...data,
      status: ContractStatus.DRAFT,
      metadata: {
        createdFromTemplate: !!data.templateId,
        merchantSpecific: true,
        autoGeneratedTerms: this.generateAutoTerms(data),
      },
    };

    const contract = await db.contract.create({
      data: {
        contractNumber: await this.generateContractNumber(),
        merchantId: data.merchantId,
        templateId: data.templateId,
        title: data.title,
        content: data.content,
        type: data.type,
        status: ContractStatus.DRAFT,

        // Données financières
        monthlyFee: data.monthlyFee ? new Decimal(data.monthlyFee) : null,
        commissionRate: data.commissionRate ? new Decimal(data.commissionRate) : null,
        minimumVolume: data.minimumVolume,

        // Extensions merchant
        merchantCategory: data.merchantCategory,
        deliveryZone: data.deliveryZone,
        maxDeliveryRadius: data.maxDeliveryRadius,
        serviceLevelAgreement: data.serviceLevelAgreement,
        volumeDiscounts: data.volumeDiscounts,
        paymentTerms: data.paymentTerms,
        exclusivityClause: data.exclusivityClause,
        territoryRestrictions: data.territoryRestrictions,
        qualityMetrics: data.qualityMetrics,
        performanceTargets: data.performanceTargets,
        penaltyClause: data.penaltyClause,
        bonusStructure: data.bonusStructure,
        insuranceRequired: data.insuranceRequired,
        insuranceAmount: data.insuranceAmount ? new Decimal(data.insuranceAmount) : null,
        securityDeposit: data.securityDeposit ? new Decimal(data.securityDeposit) : null,
        autoRenewal: data.autoRenewal,
        renewalNotice: data.renewalNotice,

        // Dates
        effectiveDate: data.effectiveDate,
        expiresAt: data.expiresAt,
        terms: data.terms,
        notes: data.notes,
        metadata: contractData.metadata,
      },
      include: {
        merchant: {
          include: { user: true },
        },
        template: true,
      },
    });

    // Initialiser le suivi de performance
    await this.initializePerformanceTracking(contract.id);

    return contract;
  }

  /**
   * Initie une négociation de contrat
   */
  async initiateNegotiation(data: ContractNegotiationInput) {
    const contract = await db.contract.findUnique({
      where: { id: data.contractId },
      include: { merchant: { include: { user: true } } },
    });

    if (!contract) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'Contrat non trouvé',
      });
    }

    // Vérifier que la négociation est possible
    if (![ContractStatus.DRAFT, ContractStatus.PENDING_SIGNATURE].includes(contract.status)) {
      throw new TRPCError({
        code: 'BAD_REQUEST',
        message: "Les négociations ne sont possibles qu'en brouillon ou en attente de signature",
      });
    }

    // Compter le nombre de tours de négociation
    const existingNegotiations = await db.contractNegotiation.count({
      where: { contractId: data.contractId },
    });

    const negotiation = await db.contractNegotiation.create({
      data: {
        contractId: data.contractId,
        initiatedBy: data.initiatedBy,
        negotiationRound: existingNegotiations + 1,
        proposedChanges: data.proposedChanges,
        reason: data.reason,
        notes: data.notes,
        status: 'PENDING',
      },
      include: {
        initiator: true,
        contract: {
          include: {
            merchant: { include: { user: true } },
          },
        },
      },
    });

    // Mettre à jour l'historique de négociation du contrat
    await this.updateNegotiationHistory(data.contractId, negotiation);

    return negotiation;
  }

  /**
   * Répond à une négociation
   */
  async respondToNegotiation(
    negotiationId: string,
    respondedBy: string,
    status: 'ACCEPTED' | 'REJECTED' | 'COUNTER_PROPOSED',
    response: string,
    counterProposal?: Record<string, any>
  ) {
    const negotiation = await db.contractNegotiation.findUnique({
      where: { id: negotiationId },
      include: {
        contract: {
          include: {
            merchant: { include: { user: true } },
          },
        },
      },
    });

    if (!negotiation) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'Négociation non trouvée',
      });
    }

    const updatedNegotiation = await db.contractNegotiation.update({
      where: { id: negotiationId },
      data: {
        status,
        response,
        respondedBy,
        respondedAt: new Date(),
      },
    });

    // Si accepté, appliquer les changements au contrat
    if (status === 'ACCEPTED') {
      await this.applyNegotiationChanges(negotiation.contractId, negotiation.proposedChanges);
    }

    // Si contre-proposition, créer une nouvelle négociation
    if (status === 'COUNTER_PROPOSED' && counterProposal) {
      await this.initiateNegotiation({
        contractId: negotiation.contractId,
        initiatedBy: respondedBy,
        proposedChanges: counterProposal,
        reason: 'Contre-proposition suite à négociation',
        notes: `En réponse à la négociation #${negotiation.negotiationRound}`,
      });
    }

    return updatedNegotiation;
  }

  /**
   * Calcule et enregistre les performances d'un contrat
   */
  async calculateContractPerformance(contractId: string, periodStart: Date, periodEnd: Date) {
    const contract = await db.contract.findUnique({
      where: { id: contractId },
      include: { merchant: true },
    });

    if (!contract) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'Contrat non trouvé',
      });
    }

    // Récupérer les données de performance sur la période
    const [deliveries, payments, ratings] = await Promise.all([
      // Statistiques de livraisons
      db.delivery.findMany({
        where: {
          // Note: merchantId doit exister dans le schéma Delivery
          // merchantId: contract.merchantId,
          createdAt: {
            gte: periodStart,
            lte: periodEnd,
          },
        },
        select: {
          id: true,
          status: true,
          createdAt: true,
          // Ajoutez d'autres champs selon votre schéma
        },
      }),

      // Statistiques de paiements
      db.payment.findMany({
        where: {
          userId: contract.merchant.userId,
          status: 'COMPLETED',
          createdAt: {
            gte: periodStart,
            lte: periodEnd,
          },
        },
        select: {
          amount: true,
        },
      }),

      // Notes de satisfaction (si disponible)
      // db.rating.findMany({...}) - à adapter selon votre schéma
      [],
    ]);

    // Calculer les métriques
    const deliveryCount = deliveries.length;
    const totalRevenue = payments.reduce((sum, p) => sum + parseFloat(p.amount.toString()), 0);
    const avgOrderValue = deliveryCount > 0 ? totalRevenue / deliveryCount : 0;

    // Calculer la conformité SLA
    const slaCompliance = this.calculateSLACompliance(contract, deliveries);

    // Vérifier les objectifs
    const targetsMet = this.checkPerformanceTargets(contract, {
      deliveryCount,
      totalRevenue,
      avgOrderValue,
      slaCompliance,
    });

    // Calculer bonus/pénalités
    const { bonusEarned, penaltiesApplied } = this.calculateBonusAndPenalties(contract, targetsMet);

    // Enregistrer les performances
    return await db.contractPerformance.create({
      data: {
        contractId,
        periodStart,
        periodEnd,
        deliveryCount,
        totalRevenue: new Decimal(totalRevenue),
        avgOrderValue: new Decimal(avgOrderValue),
        slaCompliance,
        targetsMet,
        bonusEarned: bonusEarned ? new Decimal(bonusEarned) : null,
        penaltiesApplied: penaltiesApplied ? new Decimal(penaltiesApplied) : null,
        notes: `Performance calculée automatiquement pour la période ${format(periodStart, 'dd/MM/yyyy')} - ${format(periodEnd, 'dd/MM/yyyy')}`,
      },
    });
  }

  /**
   * Planifie le renouvellement automatique des contrats
   */
  async scheduleContractRenewals() {
    const expiringContracts = await db.contract.findMany({
      where: {
        status: ContractStatus.ACTIVE,
        autoRenewal: true,
        expiresAt: {
          lte: addDays(new Date(), 30), // Contrats expirant dans 30 jours
        },
      },
      include: {
        merchant: { include: { user: true } },
      },
    });

    const renewalResults = [];

    for (const contract of expiringContracts) {
      try {
        const renewed = await this.autoRenewContract(contract.id);
        renewalResults.push({ contractId: contract.id, status: 'success', renewed });
      } catch (error) {
        renewalResults.push({
          contractId: contract.id,
          status: 'error',
          error: error instanceof Error ? error.message : 'Erreur inconnue',
        });
      }
    }

    return renewalResults;
  }

  /**
   * Méthodes privées d'aide
   */

  private async validateMerchantData(merchantId: string) {
    const merchant = await db.merchant.findUnique({
      where: { id: merchantId },
      include: { user: true },
    });

    if (!merchant) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'Commerçant non trouvé',
      });
    }

    if (!merchant.isVerified) {
      throw new TRPCError({
        code: 'PRECONDITION_FAILED',
        message: 'Le commerçant doit être vérifié avant de signer un contrat',
      });
    }

    return merchant;
  }

  private async validateContractPrerequisites(data: MerchantContractCreateInput) {
    // Vérifier les prérequis spécifiques au type de contrat
    if (data.type === ContractType.PREMIUM) {
      // Vérifications spécifiques au premium
      if (!data.insuranceRequired) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: "L'assurance est requise pour les contrats premium",
        });
      }
    }

    // Autres validations...
  }

  private generateAutoTerms(data: MerchantContractCreateInput): Record<string, any> {
    return {
      generatedAt: new Date().toISOString(),
      merchantCategory: data.merchantCategory,
      autoRenewal: data.autoRenewal,
      hasPerformanceTargets: !!data.performanceTargets,
      hasVolumeDiscounts: !!data.volumeDiscounts,
    };
  }

  private async initializePerformanceTracking(contractId: string) {
    // Initialiser le suivi de performance pour le premier mois
    const now = new Date();
    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);

    await db.contractPerformance.create({
      data: {
        contractId,
        periodStart: monthStart,
        periodEnd: monthEnd,
        deliveryCount: 0,
        notes: 'Suivi initialisé lors de la création du contrat',
      },
    });
  }

  private async updateNegotiationHistory(contractId: string, negotiation: any) {
    await db.contract.update({
      where: { id: contractId },
      data: {
        negotiationHistory: {
          // Ajouter à l'historique existant
          negotiationId: negotiation.id,
          round: negotiation.negotiationRound,
          timestamp: new Date(),
          initiator: negotiation.initiatedBy,
        },
      },
    });
  }

  private async applyNegotiationChanges(contractId: string, changes: Record<string, any>) {
    // Appliquer les changements négociés au contrat
    await db.contract.update({
      where: { id: contractId },
      data: {
        ...changes,
        lastRenegotiationDate: new Date(),
      },
    });
  }

  private calculateSLACompliance(contract: any, deliveries: any[]): number {
    // Calculer le pourcentage de respect du SLA
    // À implémenter selon vos métriques SLA
    return 95.0; // Placeholder
  }

  private checkPerformanceTargets(contract: any, metrics: any): Record<string, boolean> {
    // Vérifier si les objectifs de performance sont atteints
    const targets = contract.performanceTargets || {};
    const results: Record<string, boolean> = {};

    for (const [target, value] of Object.entries(targets)) {
      results[target] = metrics[target] >= value;
    }

    return results;
  }

  private calculateBonusAndPenalties(contract: any, targetsMet: Record<string, boolean>) {
    // Calculer les bonus et pénalités selon les résultats
    let bonusEarned = 0;
    let penaltiesApplied = 0;

    // Logique de calcul basée sur contract.bonusStructure et contract.penaltyClause

    return { bonusEarned, penaltiesApplied };
  }

  private async autoRenewContract(contractId: string) {
    const contract = await db.contract.findUnique({
      where: { id: contractId },
    });

    if (!contract) return null;

    const newExpiryDate = addMonths(contract.expiresAt!, 12);

    return await db.contract.update({
      where: { id: contractId },
      data: {
        expiresAt: newExpiryDate,
        metadata: {
          ...contract.metadata,
          autoRenewed: true,
          lastRenewalDate: new Date(),
        },
      },
    });
  }

  private async generateContractNumber(): Promise<string> {
    const date = format(new Date(), 'yyyyMM');
    const count = await db.contract.count({
      where: {
        createdAt: {
          gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
        },
      },
    });

    return `MCONT-${date}-${(count + 1).toString().padStart(4, '0')}`;
  }
}

// Export de l'instance du service
export const merchantContractService = new MerchantContractService();
