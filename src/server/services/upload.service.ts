import { createHash } from 'crypto';\nimport { v2 as cloudinary } from 'cloudinary';\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET\n});\n\nexport const UploadService = {\n  async uploadDocumentToCloudinary(file: any, userId: string, type: string) {\n    try {\n      // Générer un chemin unique\n      const hash = createHash('md5').update(${userId}_).digest('hex');\n      const path = documents///;\n      \n      // Upload vers Cloudinary\n      const result = await cloudinary.uploader.upload(file, {\n        public_id: path,\n        resource_type: 'auto',\n      });\n      \n      return {\n        url: result.secure_url,\n        publicId: result.public_id\n      };\n    } catch (error) {\n      console.error('Erreur upload Cloudinary:', error);\n      throw new Error('Échec du téléchargement du document');\n    }\n  },\n  \n  async deleteFile(publicId: string) {\n    // Suppression d'un fichier Cloudinary\n    try {\n      await cloudinary.uploader.destroy(publicId);\n      return true;\n    } catch (error) {\n      console.error('Erreur suppression Cloudinary:', error);\n      return false;\n    }\n  }\n};