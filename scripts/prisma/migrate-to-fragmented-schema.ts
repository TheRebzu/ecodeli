#!/usr/bin/env node
/**
 * Script de migration vers le sch√©ma Prisma fragment√©
 *
 * Ce script assure une transition s√©curis√©e du sch√©ma monolithique
 * vers le sch√©ma fragment√© en r√©alisant les √©tapes suivantes :
 * 1. Sauvegarde compl√®te du sch√©ma et de la base de donn√©es
 * 2. Validation de l'int√©grit√© des fragments
 * 3. G√©n√©ration du sch√©ma fusionn√©
 * 4. Tests de validation
 * 5. Migration en production
 */

import fs from "fs";
import path from "path";
import { execSync } from "child_process";
import chalk from "chalk";

// Configuration
const ROOT_DIR = process.cwd();
const BACKUP_DIR = path.join(ROOT_DIR, "prisma/backups");
const SCHEMA_PATH = path.join(ROOT_DIR, "prisma/schema.prisma");
const SCHEMA_BACKUP_PATH = path.join(
  BACKUP_DIR,
  `schema_backup_${getTimestamp()}.prisma`,
);
const DB_BACKUP_PATH = path.join(BACKUP_DIR, `db_backup_${getTimestamp()}.sql`);

// Fonction principale
async function main() {
  console.log(chalk.blue("üöÄ Migration vers le sch√©ma Prisma fragment√©"));
  console.log(chalk.gray("========================================="));

  try {
    // 1. Cr√©er un r√©pertoire de backup si n√©cessaire
    await createBackupDir();

    // 2. Sauvegarder le sch√©ma actuel
    await backupCurrentSchema();

    // 3. Sauvegarder la base de donn√©es
    await backupDatabase();

    // 4. Valider l'int√©grit√© des fragments
    await validateSchemaFragments();

    // 5. G√©n√©rer le nouveau sch√©ma
    await generateMergedSchema();

    // 6. Valider le sch√©ma g√©n√©r√©
    await validateGeneratedSchema();

    // 7. Ex√©cuter les tests automatis√©s
    await runTests();

    // 8. G√©n√©rer le client Prisma
    await generatePrismaClient();

    // 9. V√©rification post-migration
    await performPostMigrationChecks();

    console.log(
      chalk.green("\n‚úÖ Migration vers le sch√©ma fragment√© r√©ussie !"),
    );
    console.log(
      chalk.gray(
        "Pour annuler cette migration, ex√©cutez : pnpm prisma:rollback-fragmentation",
      ),
    );
  } catch (error) {
    console.error(chalk.red("\n‚ùå Erreur durant la migration:"), error);
    console.log(chalk.yellow("\nEx√©cution du rollback automatique..."));

    try {
      await rollbackMigration();
      console.log(chalk.yellow("‚úÖ Rollback effectu√© avec succ√®s."));
    } catch (rollbackError) {
      console.error(chalk.red("‚ùå Erreur durant le rollback:"), rollbackError);
      console.log(chalk.red("‚ö†Ô∏è Une intervention manuelle est n√©cessaire."));
    }

    process.exit(1);
  }
}

// Cr√©ation du r√©pertoire de backup
async function createBackupDir() {
  console.log(chalk.gray("üìÅ Pr√©paration du r√©pertoire de backup..."));

  if (!fs.existsSync(BACKUP_DIR)) {
    fs.mkdirSync(BACKUP_DIR, { recursive: true });
  }

  console.log(chalk.green("  ‚úÖ R√©pertoire de backup pr√™t"));
}

// Sauvegarde du sch√©ma actuel
async function backupCurrentSchema() {
  console.log(chalk.gray("üíæ Sauvegarde du sch√©ma Prisma actuel..."));

  if (!fs.existsSync(SCHEMA_PATH)) {
    throw new Error(
      `Le fichier schema.prisma est introuvable √† ${SCHEMA_PATH}`,
    );
  }

  fs.copyFileSync(SCHEMA_PATH, SCHEMA_BACKUP_PATH);
  console.log(
    chalk.green(
      `  ‚úÖ Sch√©ma sauvegard√© dans ${path.relative(ROOT_DIR, SCHEMA_BACKUP_PATH)}`,
    ),
  );
}

// Sauvegarde de la base de donn√©es
async function backupDatabase() {
  console.log(chalk.gray("üíæ Sauvegarde de la base de donn√©es..."));

  try {
    // Utiliser les variables d'environnement pour la connexion
    const databaseUrl = process.env.DATABASE_URL;
    if (!databaseUrl) {
      throw new Error(
        "La variable d'environnement DATABASE_URL n'est pas d√©finie",
      );
    }

    // Extraire les informations de connexion
    const url = new URL(databaseUrl);
    const host = url.hostname;
    const port = url.port;
    const database = url.pathname.substring(1);
    const username = url.username;

    // Cr√©er la commande de backup selon l'environnement
    const isWindows = process.platform === "win32";

    if (isWindows) {
      // Utiliser Docker si disponible (recommand√© pour Windows)
      console.log(chalk.gray("  Utilisation de Docker pour le backup..."));

      // V√©rifier si Docker est disponible
      try {
        execSync("docker --version", { stdio: "ignore" });
      } catch (e) {
        throw new Error(
          "Docker n'est pas install√©. Impossible de cr√©er un backup de la base de donn√©es sur Windows",
        );
      }

      // Ex√©cuter pg_dump via Docker
      execSync(
        `docker run --rm -v "${BACKUP_DIR}:/backup" -e PGPASSWORD="${url.password}" postgres:14 pg_dump -h ${host} -p ${port} -U ${username} -d ${database} -f /backup/${path.basename(DB_BACKUP_PATH)}`,
        { stdio: "inherit" },
      );
    } else {
      // Utiliser pg_dump directement sur Linux/macOS
      execSync(
        `PGPASSWORD="${url.password}" pg_dump -h ${host} -p ${port} -U ${username} -d ${database} -f ${DB_BACKUP_PATH}`,
        { stdio: "inherit" },
      );
    }

    console.log(
      chalk.green(
        `  ‚úÖ Base de donn√©es sauvegard√©e dans ${path.relative(ROOT_DIR, DB_BACKUP_PATH)}`,
      ),
    );
  } catch (error) {
    console.error(
      chalk.yellow("  ‚ö†Ô∏è Impossible de sauvegarder la base de donn√©es:"),
      error,
    );
    console.log(
      chalk.yellow(
        "  ‚ö†Ô∏è Continuation sans sauvegarde de la base. Assurez-vous d'avoir un backup r√©cent.",
      ),
    );
  }
}

// Validation des fragments de sch√©ma
async function validateSchemaFragments() {
  console.log(chalk.gray("üîç Validation des fragments de sch√©ma..."));

  try {
    execSync("pnpm db:schema:validate", { stdio: "inherit" });
    console.log(chalk.green("  ‚úÖ Fragments de sch√©ma valid√©s avec succ√®s"));
  } catch (error) {
    throw new Error(
      "La validation des fragments a √©chou√©. Corrigez les erreurs avant de continuer.",
    );
  }
}

// G√©n√©ration du sch√©ma fusionn√©
async function generateMergedSchema() {
  console.log(chalk.gray("üîÑ G√©n√©ration du sch√©ma fusionn√©..."));

  try {
    execSync("pnpm db:schema:build", { stdio: "inherit" });
    console.log(chalk.green("  ‚úÖ Sch√©ma fusionn√© g√©n√©r√© avec succ√®s"));
  } catch (error) {
    throw new Error("La g√©n√©ration du sch√©ma fusionn√© a √©chou√©.");
  }
}

// Validation du sch√©ma g√©n√©r√©
async function validateGeneratedSchema() {
  console.log(chalk.gray("üîç Validation du sch√©ma g√©n√©r√©..."));

  try {
    execSync("prisma validate", { stdio: "inherit" });
    console.log(chalk.green("  ‚úÖ Sch√©ma Prisma valid√© avec succ√®s"));
  } catch (error) {
    throw new Error("La validation du sch√©ma g√©n√©r√© a √©chou√©.");
  }
}

// Ex√©cution des tests automatis√©s
async function runTests() {
  console.log(chalk.gray("üß™ Ex√©cution des tests automatis√©s..."));

  try {
    // Ex√©cuter directement le script de validation Node.js au lieu de vitest
    execSync("node -r tsx/cjs tests/schemas/fragmentation.test.ts", {
      stdio: "inherit",
    });
    console.log(chalk.green("  ‚úÖ Tests r√©ussis"));
  } catch (error) {
    console.log(
      chalk.yellow("  ‚ö†Ô∏è Certains tests ont √©chou√©. V√©rifiez les r√©sultats."),
    );

    // Demander confirmation pour continuer
    const readline = await import("readline").then((module) =>
      module.default.createInterface({
        input: process.stdin,
        output: process.stdout,
      }),
    );

    return new Promise<void>((resolve, reject) => {
      readline.question(
        chalk.yellow(
          "  ‚ö†Ô∏è Voulez-vous continuer malgr√© les erreurs de test ? (y/N) ",
        ),
        (answer: string) => {
          readline.close();

          if (answer.toLowerCase() === "y") {
            console.log(
              chalk.yellow("  ‚ö†Ô∏è Continuation avec les erreurs de test..."),
            );
            resolve();
          } else {
            reject(
              new Error("Migration interrompue en raison d'√©checs de test."),
            );
          }
        },
      );
    });
  }
}

// G√©n√©ration du client Prisma
async function generatePrismaClient() {
  console.log(chalk.gray("üîß G√©n√©ration du client Prisma..."));

  try {
    execSync("prisma generate", { stdio: "inherit" });
    console.log(chalk.green("  ‚úÖ Client Prisma g√©n√©r√© avec succ√®s"));
  } catch (error) {
    throw new Error("La g√©n√©ration du client Prisma a √©chou√©.");
  }
}

// V√©rification post-migration
async function performPostMigrationChecks() {
  console.log(chalk.gray("üîç V√©rifications post-migration..."));

  // 1. V√©rifier que le sch√©ma fusionn√© est bien form√©
  if (!fs.existsSync(SCHEMA_PATH)) {
    throw new Error("Le fichier schema.prisma n'a pas √©t√© g√©n√©r√© correctement");
  }

  const schemaContent = fs.readFileSync(SCHEMA_PATH, "utf-8");
  if (
    !schemaContent.includes("generator client") ||
    !schemaContent.includes("datasource db")
  ) {
    throw new Error(
      "Le sch√©ma g√©n√©r√© est incomplet. V√©rifiez le contenu du fichier.",
    );
  }

  // 2. V√©rifier que les scripts package.json sont √† jour
  const packageJsonPath = path.join(ROOT_DIR, "package.json");
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));

  const requiredScripts = [
    "db:schema:build",
    "db:schema:validate",
    "db:generate",
  ];

  for (const script of requiredScripts) {
    if (!packageJson.scripts[script]) {
      console.log(
        chalk.yellow(
          `  ‚ö†Ô∏è Le script '${script}' est manquant dans package.json`,
        ),
      );
    }
  }

  console.log(chalk.green("  ‚úÖ V√©rifications post-migration termin√©es"));
}

// Rollback de la migration
async function rollbackMigration() {
  console.log(chalk.gray("üîÑ Rollback de la migration..."));

  // Restaurer le sch√©ma d'origine s'il existe
  if (fs.existsSync(SCHEMA_BACKUP_PATH)) {
    fs.copyFileSync(SCHEMA_BACKUP_PATH, SCHEMA_PATH);
    console.log(
      chalk.green(
        `  ‚úÖ Sch√©ma d'origine restaur√© depuis ${path.relative(ROOT_DIR, SCHEMA_BACKUP_PATH)}`,
      ),
    );

    // R√©g√©n√©rer le client Prisma
    execSync("prisma generate", { stdio: "inherit" });
  } else {
    throw new Error(
      "Impossible de trouver le backup du sch√©ma pour le rollback",
    );
  }
}

// Utilitaire pour obtenir un timestamp format√©
function getTimestamp(): string {
  const now = new Date();
  return now.toISOString().replace(/[:.]/g, "-");
}

// Ex√©cuter le script
main().catch((err) => {
  console.error(chalk.red("‚ùå Erreur fatale:"), err);
  process.exit(1);
});
